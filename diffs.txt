diff --git "a/pwr_baseline_1\\pwr\\src\\App.jsx" "b/pwr\\src\\App.jsx"
index 9b13331..b096aaa 100644
--- "a/pwr_baseline_1\\pwr\\src\\App.jsx"
+++ "b/pwr\\src\\App.jsx"
@@ -4,6 +4,7 @@ import Topbar from './components/Topbar'
 import ToastProvider from './components/ToastProvider'
 import { useHashRoute } from './hooks/useHashRoute'
 import { routeTitles } from './data/navigation'
+import { GlobalFilterProvider } from './contexts/GlobalFilterContext'
 
 const Dashboard = lazy(() => import('./pages/Dashboard'))
 const RevenueStructured = lazy(() => import('./pages/RevenueStructured'))
@@ -71,27 +72,29 @@ function App() {
 
   return (
     <ToastProvider>
-      <div className="app-shell">
-        <Sidebar
-          currentPath={resolvedPath}
-          onNavigate={() => setSidebarOpen(false)}
-          isOpen={sidebarOpen}
-          onClose={() => setSidebarOpen(false)}
-        />
-        <div className="app-main">
-          <Topbar
-            title={title}
-            breadcrumbs={breadcrumbs}
-            onToggleSidebar={() => setSidebarOpen(true)}
+      <GlobalFilterProvider>
+        <div className="app-shell">
+          <Sidebar
             currentPath={resolvedPath}
+            onNavigate={() => setSidebarOpen(false)}
+            isOpen={sidebarOpen}
+            onClose={() => setSidebarOpen(false)}
           />
-          <main className="page-content">
-            <Suspense fallback={<LoadingFallback />}>
-              <CurrentPage />
-            </Suspense>
-          </main>
+          <div className="app-main">
+            <Topbar
+              title={title}
+              breadcrumbs={breadcrumbs}
+              onToggleSidebar={() => setSidebarOpen(true)}
+              currentPath={resolvedPath}
+            />
+            <main className="page-content">
+              <Suspense fallback={<LoadingFallback />}>
+                <CurrentPage />
+              </Suspense>
+            </main>
+          </div>
         </div>
-      </div>
+      </GlobalFilterProvider>
     </ToastProvider>
   )
 }

diff --git "a/pwr_baseline_1\\pwr\\src\\components\\Topbar.jsx" "b/pwr\\src\\components\\Topbar.jsx"
index d3e5394..25da329 100644
--- "a/pwr_baseline_1\\pwr\\src\\components\\Topbar.jsx"
+++ "b/pwr\\src\\components\\Topbar.jsx"
@@ -1,8 +1,11 @@
 ﻿import Icon from './Icons'
+import SelectMenu from './SelectMenu'
 import { quickActions } from '../data/navigation'
+import { useGlobalFilters } from '../contexts/GlobalFilterContext'
 
 const Topbar = ({ title, breadcrumbs, onToggleSidebar, currentPath }) => {
   const actions = quickActions[currentPath] || []
+  const { selectedBroker, setSelectedBroker, brokerOptions } = useGlobalFilters()
 
   return (
     <header className="topbar">
@@ -23,6 +26,14 @@ const Topbar = ({ title, breadcrumbs, onToggleSidebar, currentPath }) => {
         </div>
       </div>
       <div className="topbar-actions">
+        <SelectMenu
+          value={selectedBroker}
+          options={brokerOptions}
+          onChange={setSelectedBroker}
+          placeholder="Broker global"
+          className="topbar-filter"
+          menuClassName="topbar-filter-menu"
+        />
         <div className="search-pill">
           <Icon name="search" size={16} />
           <input type="search" placeholder="Buscar no painel" aria-label="Buscar" />

diff --git "a/pwr_baseline_1\\pwr\\src\\index.css" "b/pwr\\src\\index.css"
index 2482965..3394445 100644
--- "a/pwr_baseline_1\\pwr\\src\\index.css"
+++ "b/pwr\\src\\index.css"
@@ -284,6 +284,19 @@ button {
   gap: 12px;
 }
 
+.topbar-filter {
+  min-width: 180px;
+}
+
+.topbar-filter .select-trigger {
+  border-radius: 999px;
+  padding: 8px 12px;
+}
+
+.topbar-filter-menu {
+  min-width: 220px;
+}
+
 .search-pill {
   display: flex;
   align-items: center;

diff --git "a/pwr_baseline_1\\pwr\\src\\components\\SyncPanel.jsx" "b/pwr\\src\\components\\SyncPanel.jsx"
index 5b4b4e5..516d0ab 100644
--- "a/pwr_baseline_1\\pwr\\src\\components\\SyncPanel.jsx"
+++ "b/pwr\\src\\components\\SyncPanel.jsx"
@@ -1,38 +1,67 @@
-﻿import { useEffect, useMemo, useState } from 'react'
+﻿import { useEffect, useMemo, useRef, useState } from 'react'
 import Icon from './Icons'
-import { syncSteps, syncResultsMock } from '../data/revenue'
 
-const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms))
+const DEFAULT_STEPS = [
+  'Selecionar fonte',
+  'Validar arquivos',
+  'Processar linhas',
+  'Consolidar base',
+  'Concluir',
+]
 
-const SyncPanel = ({ label = 'Sincronizacao inteligente', helper = 'Escolha a fonte e acompanhe o processamento.' }) => {
+const SyncPanel = ({
+  label = 'Sincronizacao inteligente',
+  helper = 'Escolha a fonte e acompanhe o processamento.',
+  onSync,
+  onFileSelected,
+  result,
+  running: runningProp,
+  steps = DEFAULT_STEPS,
+  accept = '.xlsx,.xls',
+  directory = false,
+}) => {
   const [stage, setStage] = useState(0)
-  const [running, setRunning] = useState(false)
-  const [done, setDone] = useState(false)
-  const [result, setResult] = useState(null)
+  const [runningInternal, setRunningInternal] = useState(false)
+  const [selectedFile, setSelectedFile] = useState(null)
+  const inputIdRef = useRef(`sync-${Math.random().toString(36).slice(2)}`)
+  const isControlled = typeof runningProp === 'boolean'
+  const running = isControlled ? runningProp : runningInternal
 
   const startSync = async () => {
-    if (running) return
-    setRunning(true)
-    setDone(false)
-    setResult(null)
-    for (let i = 0; i < syncSteps.length; i += 1) {
-      setStage(i)
-      // simulate step duration
-      await delay(500)
+    if (!onSync || running) return
+    if (!isControlled) setRunningInternal(true)
+    try {
+      await onSync(selectedFile)
+    } finally {
+      if (!isControlled) setRunningInternal(false)
     }
-    await delay(400)
-    setRunning(false)
-    setDone(true)
-    setResult(syncResultsMock)
   }
 
-  const progress = useMemo(() => ((stage + (running ? 0.4 : 1)) / syncSteps.length) * 100, [stage, running])
+  const progress = useMemo(() => ((stage + (running ? 0.4 : 1)) / steps.length) * 100, [stage, running, steps.length])
 
   useEffect(() => {
-    if (!running && !done) {
+    if (!running) {
       setStage(0)
+      return
     }
-  }, [running, done])
+    let active = true
+    let current = 0
+    setStage(0)
+    const timer = setInterval(() => {
+      if (!active) return
+      current = Math.min(current + 1, steps.length - 1)
+      setStage(current)
+      if (current >= steps.length - 1) {
+        clearInterval(timer)
+      }
+    }, 450)
+    return () => {
+      active = false
+      clearInterval(timer)
+    }
+  }, [running, steps.length])
+
+  const canSync = Boolean(onSync) && (directory || Boolean(selectedFile))
 
   return (
     <section className="panel sync-panel">
@@ -42,22 +71,40 @@ const SyncPanel = ({ label = 'Sincronizacao inteligente', helper = 'Escolha a fo
           <p className="muted">{helper}</p>
         </div>
         <div className="panel-actions">
-          <label className="btn btn-secondary" htmlFor="folder-select">
+          <label className="btn btn-secondary" htmlFor={inputIdRef.current}>
             <Icon name="upload" size={16} />
-            Selecionar pasta
+            {directory ? 'Selecionar pasta' : 'Selecionar arquivo'}
           </label>
-          <input id="folder-select" type="file" webkitdirectory="true" directory="true" hidden />
-          <button className="btn btn-primary" type="button" onClick={startSync}>
+          <input
+            id={inputIdRef.current}
+            type="file"
+            accept={accept}
+            onChange={(event) => {
+              const fileList = Array.from(event.target.files || [])
+              const file = fileList[0] || null
+              setSelectedFile(file)
+              onFileSelected?.(file)
+            }}
+            multiple={directory}
+            webkitdirectory={directory ? 'true' : undefined}
+            directory={directory ? 'true' : undefined}
+            hidden
+          />
+          <button className="btn btn-primary" type="button" onClick={startSync} disabled={!canSync || running}>
             <Icon name="sync" size={16} />
             {running ? 'Processando' : 'Sincronizar'}
           </button>
         </div>
       </div>
 
+      {selectedFile ? (
+        <div className="muted">Arquivo selecionado: {selectedFile.name}</div>
+      ) : null}
+
       <div className="steps">
-        {syncSteps.map((step, index) => {
+        {steps.map((step, index) => {
           const isActive = index === stage && running
-          const isDone = done || index < stage
+          const isDone = (!running && result) || index < stage
           return (
             <div key={step} className={`step ${isActive ? 'active' : ''} ${isDone ? 'done' : ''}`}>
               <div className="step-icon">

diff --git "a/pwr_baseline_1\\pwr\\src\\pages\\Tags.jsx" "b/pwr\\src\\pages\\Tags.jsx"
index 848803f..7431222 100644
--- "a/pwr_baseline_1\\pwr\\src\\pages\\Tags.jsx"
+++ "b/pwr\\src\\pages\\Tags.jsx"
@@ -1,53 +1,141 @@
-﻿import { useMemo, useState } from 'react'
+﻿import { useEffect, useMemo, useState } from 'react'
 import PageHeader from '../components/PageHeader'
 import SyncPanel from '../components/SyncPanel'
 import DataTable from '../components/DataTable'
-import Badge from '../components/Badge'
 import Icon from '../components/Icons'
-import { vinculos, vinculoResumo } from '../data/tags'
+import { formatDate } from '../utils/format'
+import { parseTagsXlsx, loadTags, saveTags } from '../services/tags'
+import { useGlobalFilters } from '../contexts/GlobalFilterContext'
+import { useToast } from '../hooks/useToast'
 
 const Tags = () => {
+  const { notify } = useToast()
+  const { userKey, refreshTags, selectedBroker } = useGlobalFilters()
   const [query, setQuery] = useState('')
+  const [running, setRunning] = useState(false)
+  const [payload, setPayload] = useState(null)
+  const [result, setResult] = useState(null)
+  const [page, setPage] = useState(1)
+  const pageSize = 200
+
+  useEffect(() => {
+    let active = true
+    const load = async () => {
+      const loaded = await loadTags(userKey)
+      if (!active) return
+      setPayload(loaded)
+      setResult(loaded?.stats || null)
+      setPage(1)
+    }
+    load()
+    return () => {
+      active = false
+    }
+  }, [userKey])
 
   const rows = useMemo(() => {
-    return vinculos.filter((item) => {
+    const items = (payload?.rows || []).map((item, index) => (
+      item.id ? item : { ...item, id: item.cliente || item.nomeCliente || `row-${index}` }
+    ))
+    return items.filter((item) => {
       const input = query.toLowerCase()
+      if (selectedBroker && item.broker !== selectedBroker) return false
       if (!input) return true
-      return `${item.cliente} ${item.assessor} ${item.broker}`.toLowerCase().includes(input)
+      return `${item.cliente} ${item.nomeCliente} ${item.assessor} ${item.broker}`.toLowerCase().includes(input)
     })
-  }, [query])
+  }, [payload, query, selectedBroker])
+
+  const totalRows = rows.length
+  const totalPages = Math.max(1, Math.ceil(totalRows / pageSize))
+  const safePage = Math.min(page, totalPages)
+  const pageStart = (safePage - 1) * pageSize
+  const pageEnd = Math.min(pageStart + pageSize, totalRows)
+  const pagedRows = rows.slice(pageStart, pageEnd)
+
+  useEffect(() => {
+    if (page > totalPages) setPage(totalPages)
+  }, [page, totalPages])
+
+  const assessorRows = useMemo(() => {
+    const map = new Map()
+    rows.forEach((item) => {
+      const assessor = item.assessor || 'Sem assessor'
+      const broker = item.broker || 'Sem broker'
+      const key = `${assessor}|||${broker}`
+      const existing = map.get(key) || { id: key, assessor, broker, total: 0 }
+      existing.total += 1
+      map.set(key, existing)
+    })
+    return Array.from(map.values()).sort((a, b) => {
+      if (a.broker === b.broker) return a.assessor.localeCompare(b.assessor, 'pt-BR')
+      return a.broker.localeCompare(b.broker, 'pt-BR')
+    })
+  }, [rows])
 
   const columns = useMemo(
     () => [
-      { key: 'cliente', label: 'Cliente' },
+      { key: 'cliente', label: 'Codigo cliente', render: (row) => row.cliente || '—' },
+      { key: 'nomeCliente', label: 'Nome do cliente', render: (row) => row.nomeCliente || row.cliente || '—' },
+      { key: 'assessor', label: 'Assessor', render: (row) => row.assessor || '—' },
+      { key: 'broker', label: 'Broker', render: (row) => row.broker || '—' },
+    ],
+    [],
+  )
+
+  const assessorColumns = useMemo(
+    () => [
       { key: 'assessor', label: 'Assessor' },
       { key: 'broker', label: 'Broker' },
-      {
-        key: 'status',
-        label: 'Status',
-        render: (row) => {
-          const tone = row.status === 'ativo' ? 'green' : row.status === 'pendente' ? 'amber' : 'violet'
-          return <Badge tone={tone}>{row.status}</Badge>
-        },
-      },
+      { key: 'total', label: 'Qtd clientes' },
     ],
     [],
   )
 
+  const lastImportedAt = payload?.importedAt ? formatDate(new Date(payload.importedAt)) : '—'
+
+  const handleSync = async (file) => {
+    if (!file) {
+      notify('Selecione o Tags.xlsx.', 'warning')
+      return
+    }
+    setRunning(true)
+    try {
+      const parsed = await parseTagsXlsx(file)
+      const saved = await saveTags(userKey, parsed)
+      const nextPayload = saved || parsed
+      setPayload(nextPayload)
+      setResult(nextPayload?.stats || parsed.stats || null)
+      await refreshTags()
+      window.dispatchEvent(new CustomEvent('pwr:tags-updated', { detail: { userKey } }))
+      notify('Tags importadas com sucesso.', 'success')
+    } catch {
+      notify('Falha ao importar Tags.xlsx.', 'warning')
+    } finally {
+      setRunning(false)
+    }
+  }
+
   return (
     <div className="page">
       <PageHeader
         title="Tags e Vinculos"
         subtitle="Hierarquia Cliente -> Assessor -> Broker com visibilidade total."
         meta={[
-          { label: 'Total vinculos', value: vinculoResumo.total },
-          { label: 'Atualizados', value: vinculoResumo.atualizados },
-          { label: 'Pendentes', value: vinculoResumo.pendentes },
+          { label: 'Total vinculos', value: payload?.rows?.length || 0 },
+          { label: 'Ultima sync', value: lastImportedAt },
+          { label: 'Avisos', value: result?.avisos ?? 0 },
         ]}
         actions={[{ label: 'Atualizar vinculos', icon: 'sync' }]}
       />
 
-      <SyncPanel label="Sincronizacao de Vinculos" helper="Importe o arquivo mestre para atualizar tags." />
+      <SyncPanel
+        label="Sincronizacao de Vinculos"
+        helper="Importe o Tags.xlsx para atualizar as tags reais."
+        onSync={handleSync}
+        running={running}
+        result={result}
+        accept=".xlsx,.xls"
+      />
 
       <section className="panel">
         <div className="panel-head">
@@ -55,26 +143,42 @@ const Tags = () => {
             <h3>Mapa de hierarquia</h3>
             <p className="muted">Visualizacao clara do relacionamento.</p>
           </div>
+          <div className="panel-actions">
+            <div className="muted">
+              Mostrando {totalRows ? pageStart + 1 : 0}-{pageEnd} de {totalRows}
+            </div>
+          </div>
         </div>
         <div className="hierarchy-grid">
-          {rows.map((item) => (
+          {pagedRows.map((item) => (
             <div key={`${item.cliente}-${item.assessor}`} className="hierarchy-card">
               <div className="hierarchy-tier">
                 <span>Cliente</span>
-                <strong>{item.cliente}</strong>
+                <strong>{item.nomeCliente || item.cliente || '—'}</strong>
+                {item.cliente ? <small className="muted">Codigo {item.cliente}</small> : null}
               </div>
               <div className="hierarchy-tier">
                 <span>Assessor</span>
-                <strong>{item.assessor}</strong>
+                <strong>{item.assessor || '—'}</strong>
               </div>
               <div className="hierarchy-tier">
                 <span>Broker</span>
-                <strong>{item.broker}</strong>
+                <strong>{item.broker || '—'}</strong>
               </div>
-              <Badge tone={item.status === 'ativo' ? 'green' : 'amber'}>{item.status}</Badge>
             </div>
           ))}
         </div>
+        {totalPages > 1 ? (
+          <div className="panel-actions">
+            <button className="btn btn-secondary" type="button" onClick={() => setPage((prev) => Math.max(1, prev - 1))} disabled={safePage <= 1}>
+              Anterior
+            </button>
+            <span className="muted">Pagina {safePage} de {totalPages}</span>
+            <button className="btn btn-secondary" type="button" onClick={() => setPage((prev) => Math.min(totalPages, prev + 1))} disabled={safePage >= totalPages}>
+              Proxima
+            </button>
+          </div>
+        ) : null}
       </section>
 
       <section className="panel">
@@ -90,7 +194,17 @@ const Tags = () => {
             </div>
           </div>
         </div>
-        <DataTable rows={rows} columns={columns} emptyMessage="Sem vinculos para exibir." />
+        <DataTable rows={pagedRows} columns={columns} emptyMessage="Sem vinculos para exibir." />
+      </section>
+
+      <section className="panel">
+        <div className="panel-head">
+          <div>
+            <h3>Tabela de assessores</h3>
+            <p className="muted">Agregado por assessor e broker.</p>
+          </div>
+        </div>
+        <DataTable rows={assessorRows} columns={assessorColumns} emptyMessage="Sem assessores para exibir." />
       </section>
     </div>
   )

diff --git "a/pwr_baseline_1\\pwr\\src\\pages\\Vencimento.jsx" "b/pwr\\src\\pages\\Vencimento.jsx"
index 499549d..4e94380 100644
--- "a/pwr_baseline_1\\pwr\\src\\pages\\Vencimento.jsx"
+++ "b/pwr\\src\\pages\\Vencimento.jsx"
@@ -16,7 +16,13 @@ import { computeBarrierStatus, computeResult } from '../services/settlement'
 import { clearOverride, loadOverrides, saveOverrides, updateOverride } from '../services/overrides'
 import { parseWorkbook, parseWorkbookBuffer } from '../services/excel'
 import { exportReportPdf } from '../services/pdf'
+import { getCurrentUserKey } from '../services/currentUser'
+import { enrichRow } from '../services/tags'
+import { clearLink, ensurePermission, isValidElectronPath, loadLink, saveLink } from '../services/vencimentoLink'
+import { clearLastImported, loadLastImported, saveLastImported } from '../services/vencimentoCache'
 import { useToast } from '../hooks/useToast'
+import { useGlobalFilters } from '../contexts/GlobalFilterContext'
+import { debugLog } from '../services/debug'
 
 const getStatus = (date) => {
   const target = new Date(date)
@@ -38,7 +44,7 @@ const getBarrierBadge = (status) => {
 }
 
 const buildCopySummary = (row) => {
-  const clienteLabel = row.codigoCliente || row.cliente || '-'
+  const clienteLabel = row.nomeCliente || row.codigoCliente || row.cliente || '-'
   return [
     `Cliente: ${clienteLabel}`,
     `Ativo: ${row.ativo}`,
@@ -130,6 +136,38 @@ const formatDayLabel = (key) => {
   return day
 }
 
+const buildFolderLabel = (link, cache) => {
+  if (link) {
+    if (link.source === 'electron') {
+      if (link.folderPath && link.fileName) return `${link.folderPath} • ${link.fileName}`
+      if (link.folderPath) return link.folderPath
+    }
+    if (link.source === 'browser') {
+      const folder = link.folderName || 'Pasta'
+      const file = link.fileName || cache?.fileName
+      return file ? `${folder} • ${file}` : folder
+    }
+    if (link.fileName) return link.fileName
+  }
+  if (cache?.fileName) return `${cache.fileName} • cache`
+  return 'Nenhuma pasta vinculada'
+}
+
+const pickFileFromDirectoryHandle = async (handle) => {
+  if (!handle) return null
+  const files = []
+  for await (const entry of handle.values()) {
+    const lowerName = entry.name.toLowerCase()
+    if (entry.kind === 'file' && (lowerName.endsWith('.xlsx') || lowerName.endsWith('.xls')) && !entry.name.startsWith('~$')) {
+      const file = await entry.getFile()
+      files.push(file)
+    }
+  }
+  const pickedFile = pickPreferredFile(files)
+  if (!pickedFile) return null
+  return { file: pickedFile, folderName: handle.name, fileName: pickedFile.name }
+}
+
 const buildVencimentoTree = (items) => {
   const years = new Map()
   const allValues = new Set()
@@ -292,35 +330,300 @@ const resolveSpotBase = (operation, market) => {
 
 const Vencimento = () => {
   const { notify } = useToast()
-  const [filters, setFilters] = useState({ search: '', broker: '', assessor: '', cliente: '', status: '', estrutura: '', vencimentos: [] })
+  const { selectedBroker, clientCodeFilter, setClientCodeFilter, tagsIndex } = useGlobalFilters()
+  const [userKey] = useState(() => getCurrentUserKey())
+  const [filters, setFilters] = useState({ search: '', broker: '', assessor: '', status: '', estrutura: '', vencimentos: [] })
   const [operations, setOperations] = useState(vencimentos)
   const [marketMap, setMarketMap] = useState({})
-  const [overrides, setOverrides] = useState(() => loadOverrides())
+  const [overrides, setOverrides] = useState(() => loadOverrides(userKey))
   const [selectedReport, setSelectedReport] = useState(null)
   const [selectedOverride, setSelectedOverride] = useState(null)
-  const [overrideDraft, setOverrideDraft] = useState({ high: 'auto', low: 'auto', cupomManual: '', qtyBonus: 0, bonusDate: '', bonusNote: '' })
-  const [folderLabel, setFolderLabel] = useState('Nenhuma pasta vinculada')
+  const [overrideDraft, setOverrideDraft] = useState({ high: 'auto', low: 'auto', manualCouponBRL: '', qtyBonus: 0, bonusDate: '', bonusNote: '' })
+  const [linkMeta, setLinkMeta] = useState(null)
+  const [cacheMeta, setCacheMeta] = useState(null)
+  const [restoreStatus, setRestoreStatus] = useState({ state: 'idle', message: '' })
+  const [permissionState, setPermissionState] = useState(null)
   const [pendingFile, setPendingFile] = useState(null)
   const [isParsing, setIsParsing] = useState(false)
+  const [isRestoring, setIsRestoring] = useState(false)
   const [isRefreshingAll, setIsRefreshingAll] = useState(false)
   const [currentPage, setCurrentPage] = useState(1)
   const fileInputRef = useRef(null)
+  const broadcastRef = useRef(null)
+  const tabIdRef = useRef(Math.random().toString(36).slice(2))
+  const restoreRef = useRef({ running: false })
+
+  const folderLabel = useMemo(() => {
+    if (pendingFile) {
+      if (pendingFile.source === 'electron') {
+        if (pendingFile.folderPath && pendingFile.fileName) return `${pendingFile.folderPath} • ${pendingFile.fileName}`
+        if (pendingFile.folderPath) return pendingFile.folderPath
+      }
+      if (pendingFile.source === 'browser') {
+        const folder = pendingFile.folderName || pendingFile.handle?.name || 'Pasta'
+        const fileName = pendingFile.fileName || pendingFile.file?.name
+        return fileName ? `${folder} • ${fileName}` : folder
+      }
+      if (pendingFile.file?.name) return pendingFile.file.name
+    }
+    return buildFolderLabel(linkMeta, cacheMeta)
+  }, [pendingFile, linkMeta, cacheMeta])
 
   useEffect(() => {
-    saveOverrides(overrides)
-  }, [overrides])
+    if (!userKey) return
+    setOverrides(loadOverrides(userKey))
+  }, [userKey])
 
   useEffect(() => {
-    if (!window?.electronAPI?.resolveFolder) return
-    const savedFolder = window.localStorage.getItem('pwr.vencimento.folder')
-    if (!savedFolder) return
-    window.electronAPI.resolveFolder(savedFolder).then((meta) => {
-      if (!meta?.filePath) return
-      setPendingFile({ source: 'electron', ...meta })
-      setFolderLabel(`${meta.folderPath} • ${meta.fileName}`)
-    })
+    if (!userKey) return
+    saveOverrides(userKey, overrides)
+  }, [overrides, userKey])
+
+  const broadcastUpdate = useCallback((type, payload = {}) => {
+    if (!userKey) return
+    const message = {
+      type,
+      userKey,
+      sender: tabIdRef.current,
+      ts: Date.now(),
+      ...payload,
+    }
+    if (broadcastRef.current) {
+      broadcastRef.current.postMessage(message)
+    } else {
+      try {
+        localStorage.setItem('pwr.vencimento.broadcast', JSON.stringify(message))
+      } catch {
+        // noop
+      }
+    }
+  }, [userKey])
+
+  const hydrateCache = useCallback((cache) => {
+    setCacheMeta(cache || null)
+    if (cache?.rows?.length) {
+      setOperations(cache.rows)
+    } else if (!cache) {
+      setOperations(vencimentos)
+    }
   }, [])
 
+  const applyPendingFile = useCallback(async (nextPending, { save = true, silent = false } = {}) => {
+    if (!nextPending) return false
+    setIsParsing(true)
+    let parsedRows = null
+    let parseSource = nextPending?.source || 'browser'
+    const fileName = nextPending?.fileName || nextPending?.file?.name || null
+
+    try {
+      if (nextPending?.source === 'electron') {
+        if (!window?.electronAPI?.readFile) throw new Error('electron-unavailable')
+        const raw = await window.electronAPI.readFile(nextPending.filePath)
+        const buffer = toArrayBuffer(raw)
+        if (!buffer) throw new Error('buffer-invalid')
+        parsedRows = await parseWorkbookBuffer(buffer)
+        parseSource = 'electron'
+      } else {
+        const file = nextPending?.file || nextPending
+        try {
+          const formData = new FormData()
+          formData.append('file', file)
+          const response = await fetch('/api/vencimentos/parse', {
+            method: 'POST',
+            body: formData,
+          })
+          if (!response.ok) throw new Error('api-failed')
+          const data = await response.json()
+          if (!data?.rows) throw new Error('api-invalid')
+          parsedRows = data.rows
+          parseSource = 'api'
+        } catch {
+          parsedRows = await parseWorkbook(file)
+          parseSource = 'local'
+          if (!silent) {
+            notify('API indisponivel. Calculo local aplicado.', 'warning')
+          }
+        }
+      }
+
+      if (!parsedRows) throw new Error('parse-empty')
+      const withSpot = await attachSpotPrices(parsedRows)
+      debugLog('vencimento.restore.parse', { rows: withSpot.length, source: parseSource })
+      setOperations(withSpot)
+      const storedCache = saveLastImported(userKey, {
+        rows: withSpot,
+        fileName,
+        importedAt: Date.now(),
+        source: parseSource,
+      })
+      setCacheMeta(storedCache)
+
+      if (save) {
+        if (nextPending?.source === 'electron' && isValidElectronPath(nextPending.folderPath)) {
+          const saved = await saveLink(userKey, {
+            source: 'electron',
+            folderPath: nextPending.folderPath,
+            fileName: nextPending.fileName || fileName,
+          })
+          if (saved) setLinkMeta(saved)
+        } else if (nextPending?.source === 'browser' && nextPending.handle) {
+          const saved = await saveLink(userKey, {
+            source: 'browser',
+            handle: nextPending.handle,
+            folderName: nextPending.folderName || nextPending.handle?.name,
+            fileName,
+          })
+          if (saved) setLinkMeta(saved)
+        } else {
+          const saved = await saveLink(userKey, {
+            source: 'file',
+            fileName,
+          })
+          if (saved) setLinkMeta(saved)
+        }
+        broadcastUpdate('vencimento-updated', { kind: 'link' })
+      }
+
+      broadcastUpdate('vencimento-updated', { kind: 'cache' })
+      if (!silent) notify('Planilha vinculada e calculada.', 'success')
+      setPendingFile(null)
+      return true
+    } catch {
+      if (!silent) notify('Falha ao calcular os dados da planilha.', 'warning')
+      return false
+    } finally {
+      setIsParsing(false)
+    }
+  }, [broadcastUpdate, notify, userKey])
+
+  const restoreFromLink = useCallback(async (link, { silent = true } = {}) => {
+    if (!link || restoreRef.current.running) return
+    restoreRef.current.running = true
+    setIsRestoring(true)
+    setRestoreStatus({ state: 'restoring', message: 'Restaurando vinculo salvo...' })
+    debugLog('vencimento.restore.link', { source: link.source })
+    try {
+      if (link.source === 'electron') {
+        if (!window?.electronAPI?.resolveFolder || !isValidElectronPath(link.folderPath)) {
+          setRestoreStatus({ state: 'error', message: 'Vinculo salvo invalido.' })
+          return
+        }
+        const meta = await window.electronAPI.resolveFolder(link.folderPath)
+        if (!meta?.filePath) {
+          setRestoreStatus({ state: 'error', message: 'Pasta nao encontrada ou sem permissao.' })
+          return
+        }
+        const nextPending = { source: 'electron', ...meta }
+        setPendingFile(nextPending)
+        await applyPendingFile(nextPending, { save: false, silent })
+        setRestoreStatus({ state: 'idle', message: '' })
+        return
+      }
+
+      if (link.source === 'browser') {
+        const handle = link.handle
+        if (!handle) {
+          setRestoreStatus({ state: 'needs-permission', message: 'Permissao pendente para a pasta.' })
+          return
+        }
+        const permission = await ensurePermission(handle)
+        setPermissionState(permission)
+        if (permission !== 'granted') {
+          setRestoreStatus({ state: 'needs-permission', message: 'Reautorize o acesso a pasta para restaurar.' })
+          return
+        }
+        const picked = await pickFileFromDirectoryHandle(handle)
+        if (!picked?.file) {
+          setRestoreStatus({ state: 'error', message: 'Planilha nao encontrada na pasta vinculada.' })
+          return
+        }
+        const nextPending = { source: 'browser', handle, ...picked }
+        setPendingFile(nextPending)
+        await applyPendingFile(nextPending, { save: false, silent })
+        setRestoreStatus({ state: 'idle', message: '' })
+        return
+      }
+
+      if (link.source === 'file') {
+        setRestoreStatus({ state: 'idle', message: cacheMeta?.rows?.length ? '' : 'Cache local pronto para uso.' })
+      }
+    } finally {
+      restoreRef.current.running = false
+      setIsRestoring(false)
+    }
+  }, [applyPendingFile, cacheMeta?.rows?.length])
+
+  const restoreFromStorage = useCallback(async ({ reparse = false } = {}) => {
+    if (!userKey) return
+    const cached = loadLastImported(userKey)
+    hydrateCache(cached)
+    const link = await loadLink(userKey)
+    debugLog('vencimento.restore.storage', { hasCache: Boolean(cached?.rows?.length), linkSource: link?.source || null })
+    setLinkMeta(link || null)
+    setPermissionState(null)
+    if (!link) {
+      if (cached?.rows?.length) {
+        setRestoreStatus({ state: 'idle', message: 'Dados restaurados do cache local.' })
+      } else {
+        setRestoreStatus({ state: 'idle', message: '' })
+      }
+      return
+    }
+    if (reparse) {
+      await restoreFromLink(link, { silent: true })
+    }
+  }, [hydrateCache, restoreFromLink, userKey])
+
+  useEffect(() => {
+    if (!userKey) return
+    if (typeof BroadcastChannel !== 'undefined') {
+      const channel = new BroadcastChannel('pwr:vencimento')
+      broadcastRef.current = channel
+      channel.onmessage = (event) => {
+        const message = event?.data
+        if (!message || message.sender === tabIdRef.current) return
+        if (message.userKey !== userKey) return
+        restoreFromStorage({ reparse: false })
+      }
+    }
+
+    const handleStorage = (event) => {
+      if (!event?.key) return
+      if (event.key === 'pwr.vencimento.broadcast') {
+        const payload = (() => {
+          try {
+            return JSON.parse(event.newValue || '{}')
+          } catch {
+            return null
+          }
+        })()
+        if (!payload || payload.sender === tabIdRef.current) return
+        if (payload.userKey !== userKey) return
+        restoreFromStorage({ reparse: false })
+        return
+      }
+      if (event.key.startsWith('pwr.vencimento.link.') || event.key.startsWith('pwr.vencimento.cache.')) {
+        if (!event.key.endsWith(userKey)) return
+        restoreFromStorage({ reparse: false })
+      }
+    }
+
+    window.addEventListener('storage', handleStorage)
+
+    return () => {
+      window.removeEventListener('storage', handleStorage)
+      if (broadcastRef.current) {
+        broadcastRef.current.close()
+        broadcastRef.current = null
+      }
+    }
+  }, [restoreFromStorage, userKey])
+
+  useEffect(() => {
+    if (!userKey) return
+    restoreFromStorage({ reparse: true })
+  }, [restoreFromStorage, userKey])
+
   useEffect(() => {
     let active = true
     const loadMarket = async () => {
@@ -366,12 +669,16 @@ const Vencimento = () => {
     }
   }, [operations])
 
-  const brokerOptions = useMemo(() => buildOptions(operations.map((item) => item.broker), 'Broker'), [operations])
-  const assessorOptions = useMemo(() => buildOptions(operations.map((item) => item.assessor), 'Assessor'), [operations])
-  const estruturaOptions = useMemo(() => buildOptions(operations.map((item) => item.estrutura), 'Estrutura'), [operations])
+  const enrichedOperations = useMemo(
+    () => operations.map((operation) => enrichRow(operation, tagsIndex)),
+    [operations, tagsIndex],
+  )
+  const brokerOptions = useMemo(() => buildOptions(enrichedOperations.map((item) => item.broker), 'Broker'), [enrichedOperations])
+  const assessorOptions = useMemo(() => buildOptions(enrichedOperations.map((item) => item.assessor), 'Assessor'), [enrichedOperations])
+  const estruturaOptions = useMemo(() => buildOptions(enrichedOperations.map((item) => item.estrutura), 'Estrutura'), [enrichedOperations])
   const { tree: vencimentoTree, allValues: vencimentoValues } = useMemo(
-    () => buildVencimentoTree(operations),
-    [operations],
+    () => buildVencimentoTree(enrichedOperations),
+    [enrichedOperations],
   )
 
   const handleRefreshData = useCallback(async (operation) => {
@@ -400,22 +707,38 @@ const Vencimento = () => {
 
   const rows = useMemo(() => {
     const vencimentoSet = new Set(filters.vencimentos)
-    return operations
+    return enrichedOperations
       .map((operation) => {
         const market = marketMap[operation.id]
-        const override = overrides[operation.id] || { high: 'auto', low: 'auto', cupomManual: '', qtyBonus: 0, bonusDate: '', bonusNote: '' }
+        const override = overrides[operation.id] || { high: 'auto', low: 'auto', manualCouponBRL: null, manualCouponPct: null, qtyBonus: 0, bonusDate: '', bonusNote: '' }
         const qtyBase = parseQuantity(operation.qtyBase ?? operation.quantidade ?? 0)
-        const qtyBonus = Math.max(0, parseQuantity(override.qtyBonus ?? operation.qtyBonus ?? 0))
-        const qtyAtual = Math.max(0, qtyBase + qtyBonus)
+        const qtyAtualRaw = operation.qtyAtual ?? operation.quantidadeAtual
+        const qtyAtualSource = parseQuantity(qtyAtualRaw)
+        const hasQtyAtualSource = qtyAtualRaw != null && qtyAtualSource > 0
+        const overrideBonus = parseQuantity(override.qtyBonus ?? 0)
+        const hasOverrideBonus = overrideBonus > 0
+        const qtyBonus = hasOverrideBonus
+          ? overrideBonus
+          : hasQtyAtualSource
+            ? Math.max(0, qtyAtualSource - qtyBase)
+            : 0
+        const qtyAtual = hasOverrideBonus
+          ? Math.max(0, qtyBase + qtyBonus)
+          : hasQtyAtualSource
+            ? qtyAtualSource
+            : Math.max(0, qtyBase + qtyBonus)
         const spotBase = resolveSpotBase(operation, market)
         const operationWithSpot = spotBase != null
           ? { ...operation, spotInicial: spotBase, qtyBase, qtyBonus, qtyAtual }
           : { ...operation, qtyBase, qtyBonus, qtyAtual }
         const barrierStatus = computeBarrierStatus(operationWithSpot, market, override)
-        const cupomManual = override?.cupomManual != null && String(override.cupomManual).trim() !== ''
-          ? override.cupomManual
+        const manualCouponBRL = override?.manualCouponBRL != null && Number.isFinite(Number(override.manualCouponBRL))
+          ? Number(override.manualCouponBRL)
           : null
-        const cupomResolved = cupomManual ?? operation.cupom
+        const legacyCouponLabel = override?.manualCouponPct || null
+        const cupomResolved = manualCouponBRL != null
+          ? formatCurrency(manualCouponBRL)
+          : (legacyCouponLabel || operation.cupom || 'N/A')
         const result = computeResult(operationWithSpot, market, barrierStatus, override)
         return {
           ...operation,
@@ -425,7 +748,8 @@ const Vencimento = () => {
           market,
           spotBase,
           override,
-          cupomManual,
+          manualCouponBRL,
+          legacyCouponLabel,
           cupomResolved,
           barrierStatus,
           result,
@@ -434,18 +758,21 @@ const Vencimento = () => {
       })
       .filter((entry) => {
         const query = filters.search.toLowerCase()
-        const searchBase = `${entry.codigoCliente || entry.cliente || ''} ${entry.ativo || ''} ${entry.estrutura || ''} ${entry.assessor || ''} ${entry.broker || ''}`.toLowerCase()
+        const searchBase = `${entry.codigoCliente || ''} ${entry.cliente || ''} ${entry.nomeCliente || ''} ${entry.ativo || ''} ${entry.estrutura || ''} ${entry.assessor || ''} ${entry.broker || ''}`.toLowerCase()
         if (query && !searchBase.includes(query)) return false
+        if (selectedBroker && entry.broker !== selectedBroker) return false
         if (filters.broker && entry.broker !== filters.broker) return false
         if (filters.assessor && entry.assessor !== filters.assessor) return false
-        const clienteMatch = entry.codigoCliente || entry.cliente
-        if (filters.cliente && clienteMatch !== filters.cliente) return false
+        if (clientCodeFilter) {
+          const clienteMatch = String(entry.codigoCliente || entry.cliente || '').trim()
+          if (clienteMatch !== String(clientCodeFilter).trim()) return false
+        }
         if (filters.estrutura && entry.estrutura !== filters.estrutura) return false
         if (vencimentoSet.size && !vencimentoSet.has(normalizeDateKey(entry.vencimento))) return false
         if (filters.status && entry.status.key !== filters.status) return false
         return true
       })
-  }, [filters, operations, marketMap, overrides])
+  }, [clientCodeFilter, enrichedOperations, filters, marketMap, overrides, selectedBroker])
 
   const pageCount = useMemo(() => Math.max(1, Math.ceil(rows.length / PAGE_SIZE)), [rows.length])
   const paginationItems = useMemo(() => buildPagination(currentPage, pageCount), [currentPage, pageCount])
@@ -454,7 +781,7 @@ const Vencimento = () => {
   }, [pageCount])
   useEffect(() => {
     setCurrentPage(1)
-  }, [filters, operations])
+  }, [filters, operations, selectedBroker, clientCodeFilter])
 
   const pageStart = (currentPage - 1) * PAGE_SIZE
   const visibleRows = useMemo(() => rows.slice(pageStart, pageStart + PAGE_SIZE), [rows, pageStart])
@@ -527,8 +854,8 @@ const Vencimento = () => {
   }, [])
 
   const handleOverrideClick = useCallback((row) => {
-    const current = overrides[row.id] || { high: 'auto', low: 'auto', cupomManual: '', qtyBonus: 0, bonusDate: '', bonusNote: '' }
-    setOverrideDraft(current)
+    const current = overrides[row.id] || { high: 'auto', low: 'auto', manualCouponBRL: '', qtyBonus: 0, bonusDate: '', bonusNote: '' }
+    setOverrideDraft({ ...current, manualCouponBRL: current.manualCouponBRL ?? '' })
     setSelectedOverride(row)
   }, [overrides])
 
@@ -634,7 +961,11 @@ const Vencimento = () => {
       {
         key: 'ganhosOpcoes',
         label: 'Ganho nas opcoes',
-        render: (row) => formatCurrency(row.result.ganhosOpcoes),
+        render: (row) => (
+          row.result.optionsSuppressed
+            ? <span className="muted">N/A</span>
+            : formatCurrency(row.result.ganhosOpcoes)
+        ),
       },
       {
         key: 'dividendos',
@@ -645,12 +976,20 @@ const Vencimento = () => {
         key: 'cupom',
         label: 'Cupom',
         render: (row) => {
-          const manual = row.cupomManual != null
+          const manual = row.manualCouponBRL != null
+          const legacyNeedsInput = row.result.cupomLegacyNeedsInput
+          const legacyConverted = row.result.cupomLegacyConverted
           const label = row.cupomResolved || row.cupom || 'N/A'
           return (
             <div className="cell-stack">
               <strong>{label}</strong>
-              {manual ? <small>Manual</small> : <small>Automatico</small>}
+              {legacyNeedsInput
+                ? <small className="muted">Precisa reentrada</small>
+                : manual
+                  ? <small>Manual</small>
+                  : legacyConverted
+                    ? <small>Legado</small>
+                    : <small>Automatico</small>}
             </div>
           )
         },
@@ -710,12 +1049,12 @@ const Vencimento = () => {
     : ''
 
   const chips = [
-    { key: 'broker', label: filters.broker },
-    { key: 'assessor', label: filters.assessor },
-    { key: 'cliente', label: filters.cliente },
-    { key: 'estrutura', label: filters.estrutura },
-    { key: 'vencimentos', label: vencimentoChipLabel },
-    { key: 'status', label: filters.status },
+    { key: 'broker', label: filters.broker, onClear: () => setFilters((prev) => ({ ...prev, broker: '' })) },
+    { key: 'assessor', label: filters.assessor, onClear: () => setFilters((prev) => ({ ...prev, assessor: '' })) },
+    { key: 'clientCode', label: clientCodeFilter, onClear: () => setClientCodeFilter('') },
+    { key: 'estrutura', label: filters.estrutura, onClear: () => setFilters((prev) => ({ ...prev, estrutura: '' })) },
+    { key: 'vencimentos', label: vencimentoChipLabel, onClear: () => setFilters((prev) => ({ ...prev, vencimentos: [] })) },
+    { key: 'status', label: filters.status, onClear: () => setFilters((prev) => ({ ...prev, status: '' })) },
   ].filter((chip) => chip.label)
 
   const handlePickFolder = useCallback(async () => {
@@ -726,31 +1065,39 @@ const Vencimento = () => {
           notify('Selecao de pasta cancelada.', 'warning')
           return
         }
-        setPendingFile({ source: 'electron', ...meta })
-        setFolderLabel(`${meta.folderPath} • ${meta.fileName}`)
-        window.localStorage.setItem('pwr.vencimento.folder', meta.folderPath)
+        const nextPending = { source: 'electron', ...meta }
+        setPendingFile(nextPending)
+        if (isValidElectronPath(meta.folderPath)) {
+          const saved = await saveLink(userKey, {
+            source: 'electron',
+            folderPath: meta.folderPath,
+            fileName: meta.fileName,
+          })
+          if (saved) setLinkMeta(saved)
+          broadcastUpdate('vencimento-updated', { kind: 'link' })
+        }
         notify('Pasta vinculada. Clique em calcular.', 'success')
         return
       }
       if ('showDirectoryPicker' in window) {
         const handle = await window.showDirectoryPicker()
-        let pickedFile = null
-        const files = []
-        for await (const entry of handle.values()) {
-          const lowerName = entry.name.toLowerCase()
-          if (entry.kind === 'file' && (lowerName.endsWith('.xlsx') || lowerName.endsWith('.xls')) && !entry.name.startsWith('~$')) {
-            const file = await entry.getFile()
-            files.push(file)
-          }
-        }
-        pickedFile = pickPreferredFile(files)
-        if (!pickedFile) {
+        const picked = await pickFileFromDirectoryHandle(handle)
+        if (!picked?.file) {
           notify('Nenhuma planilha .xlsx encontrada.', 'warning')
           setPendingFile(null)
           return
         }
-        setPendingFile({ source: 'browser', file: pickedFile })
-        setFolderLabel(`${handle.name} • ${pickedFile.name}`)
+        const nextPending = { source: 'browser', handle, ...picked }
+        setPendingFile(nextPending)
+        setPermissionState('granted')
+        const saved = await saveLink(userKey, {
+          source: 'browser',
+          handle,
+          folderName: picked.folderName,
+          fileName: picked.fileName,
+        })
+        if (saved) setLinkMeta(saved)
+        broadcastUpdate('vencimento-updated', { kind: 'link' })
         notify('Pasta selecionada. Clique em vincular para calcular.', 'success')
       } else {
         fileInputRef.current?.click()
@@ -758,7 +1105,7 @@ const Vencimento = () => {
     } catch {
       notify('Selecao de pasta cancelada.', 'warning')
     }
-  }, [notify])
+  }, [broadcastUpdate, notify, userKey])
 
   const handleFileChange = async (event) => {
     const files = Array.from(event.target.files || [])
@@ -767,8 +1114,14 @@ const Vencimento = () => {
       notify('Selecione um arquivo .xlsx.', 'warning')
       return
     }
-    setFolderLabel(file.name)
-    setPendingFile({ source: 'browser', file })
+    const nextPending = { source: 'file', file, fileName: file.name }
+    setPendingFile(nextPending)
+    const saved = await saveLink(userKey, {
+      source: 'file',
+      fileName: file.name,
+    })
+    if (saved) setLinkMeta(saved)
+    broadcastUpdate('vencimento-updated', { kind: 'link' })
     notify('Planilha pronta. Clique em vincular para calcular.', 'success')
   }
 
@@ -777,48 +1130,39 @@ const Vencimento = () => {
       notify('Escolha a pasta/planilha antes de vincular.', 'warning')
       return
     }
-    setIsParsing(true)
-    try {
-      if (pendingFile?.source === 'electron') {
-        const raw = await window.electronAPI.readFile(pendingFile.filePath)
-        const buffer = toArrayBuffer(raw)
-        if (!buffer) throw new Error('buffer-invalid')
-        const parsed = await parseWorkbookBuffer(buffer)
-        const withSpot = await attachSpotPrices(parsed)
-        setOperations(withSpot)
-        notify('Planilha vinculada e calculada.', 'success')
-        return
-      }
-      const formData = new FormData()
-      formData.append('file', pendingFile?.file || pendingFile)
-      const response = await fetch('/api/vencimentos/parse', {
-        method: 'POST',
-        body: formData,
-      })
-      if (!response.ok) throw new Error('api-failed')
-      const data = await response.json()
-      if (!data?.rows) throw new Error('api-invalid')
-      const withSpot = await attachSpotPrices(data.rows)
-      setOperations(withSpot)
-      notify('Planilha vinculada e calculada.', 'success')
-    } catch {
-      try {
-        const file = pendingFile?.file || pendingFile
-        const parsed = await parseWorkbook(file)
-        const withSpot = await attachSpotPrices(parsed)
-        setOperations(withSpot)
-        notify('API indisponivel. Calculo local aplicado.', 'warning')
-      } catch {
-        notify('Falha ao calcular os dados da planilha.', 'warning')
-      }
-    } finally {
-      setIsParsing(false)
+    await applyPendingFile(pendingFile, { save: true, silent: false })
+  }, [applyPendingFile, notify, pendingFile])
+
+  const handleReauthorize = useCallback(async () => {
+    if (!linkMeta?.handle) {
+      notify('Nenhuma pasta para reautorizar.', 'warning')
+      return
     }
-  }, [pendingFile, notify])
+    const state = await ensurePermission(linkMeta.handle, { interactive: true })
+    setPermissionState(state)
+    if (state === 'granted') {
+      await restoreFromLink(linkMeta, { silent: false })
+    } else {
+      setRestoreStatus({ state: 'needs-permission', message: 'Permissao nao concedida.' })
+    }
+  }, [linkMeta, notify, restoreFromLink])
+
+  const handleUnlink = useCallback(async () => {
+    await clearLink(userKey)
+    clearLastImported(userKey)
+    setLinkMeta(null)
+    setCacheMeta(null)
+    setPendingFile(null)
+    setPermissionState(null)
+    setRestoreStatus({ state: 'idle', message: '' })
+    setOperations(vencimentos)
+    broadcastUpdate('vencimento-updated', { kind: 'clear' })
+    notify('Vinculo removido.', 'success')
+  }, [broadcastUpdate, notify, userKey])
 
   const handleExportPdf = (row) => {
     const barrierBadge = getBarrierBadge(row.barrierStatus)
-    const clienteLabel = row.cliente || row.codigoCliente || 'Cliente'
+    const clienteLabel = row.nomeCliente || row.cliente || row.codigoCliente || 'Cliente'
     const payload = {
       title: `Relatorio - ${clienteLabel}`,
       header: `${row.ativo} | ${row.estrutura} | ${formatDate(row.vencimento)}`,
@@ -833,9 +1177,9 @@ const Vencimento = () => {
         { label: 'Ganho/Prejuizo', value: formatCurrency(row.result.ganho) },
         { label: 'Ganho %', value: `${(row.result.percent * 100).toFixed(2)}%` },
         { label: 'Venda do ativo', value: formatCurrency(row.result.vendaAtivo) },
-        { label: 'Ganho na Call', value: formatCurrency(row.result.ganhoCall) },
-        { label: 'Ganho na Put', value: formatCurrency(row.result.ganhoPut) },
-        { label: 'Ganhos nas opcoes', value: formatCurrency(row.result.ganhosOpcoes) },
+        { label: 'Ganho na Call', value: row.result.optionsSuppressed ? 'N/A' : formatCurrency(row.result.ganhoCall) },
+        { label: 'Ganho na Put', value: row.result.optionsSuppressed ? 'N/A' : formatCurrency(row.result.ganhoPut) },
+        { label: 'Ganhos nas opcoes', value: row.result.optionsSuppressed ? 'N/A' : formatCurrency(row.result.ganhosOpcoes) },
         { label: 'Dividendos', value: formatCurrency(row.result.dividends) },
         { label: 'Cupom', value: formatCurrency(row.result.cupomTotal) },
         { label: 'Rebates', value: formatCurrency(row.result.rebateTotal) },
@@ -851,7 +1195,7 @@ const Vencimento = () => {
       warnings: [
         row.market?.source !== 'yahoo' ? 'Cotacao em fallback.' : null,
         row.override?.high !== 'auto' || row.override?.low !== 'auto' ? 'Override manual aplicado.' : null,
-        row.cupomManual != null && String(row.cupomManual).trim() !== '' ? 'Cupom manual aplicado.' : null,
+        row.manualCouponBRL != null ? 'Cupom manual aplicado.' : null,
       ].filter(Boolean),
     }
     exportReportPdf(payload, `${clienteLabel}_${row.ativo}_${row.vencimento}`)
@@ -866,6 +1210,13 @@ const Vencimento = () => {
     }
   }
 
+  const hasLink = Boolean(linkMeta)
+  const showReauthorize = Boolean(
+    linkMeta?.source === 'browser'
+    && (permissionState === 'prompt' || permissionState === 'denied' || restoreStatus.state === 'needs-permission'),
+  )
+  const isBusy = isParsing || isRestoring
+
   return (
     <div className="page">
       <PageHeader
@@ -886,18 +1237,30 @@ const Vencimento = () => {
             <p className="muted">Vincule a pasta com a planilha de posicao para atualizar os calculos.</p>
           </div>
           <div className="panel-actions">
-            <button className="btn btn-secondary" type="button" onClick={handlePickFolder}>
+            {showReauthorize ? (
+              <button className="btn btn-secondary" type="button" onClick={handleReauthorize} disabled={isBusy}>
+                <Icon name="sync" size={16} />
+                Reautorizar
+              </button>
+            ) : null}
+            <button className="btn btn-secondary" type="button" onClick={handlePickFolder} disabled={isBusy}>
               <Icon name="link" size={16} />
-              Vincular pasta
+              {hasLink ? 'Trocar pasta' : 'Vincular pasta'}
             </button>
+            {hasLink ? (
+              <button className="btn btn-secondary" type="button" onClick={handleUnlink} disabled={isBusy}>
+                <Icon name="close" size={16} />
+                Desvincular
+              </button>
+            ) : null}
             <button
               className="btn btn-primary"
               type="button"
               onClick={handleApplyFolder}
-              disabled={!pendingFile || isParsing}
+              disabled={!pendingFile || isBusy}
             >
               <Icon name="sync" size={16} />
-              {isParsing ? 'Calculando...' : 'Vincular e calcular'}
+              {isBusy ? 'Calculando...' : 'Vincular e calcular'}
             </button>
             <input
               ref={fileInputRef}
@@ -912,6 +1275,7 @@ const Vencimento = () => {
           </div>
         </div>
         <div className="muted">{folderLabel}</div>
+        {restoreStatus.message ? <div className="muted">{restoreStatus.message}</div> : null}
       </section>
 
       <section className="panel">
@@ -958,7 +1322,12 @@ const Vencimento = () => {
             onChange={(value) => setFilters((prev) => ({ ...prev, vencimentos: value }))}
             placeholder="Vencimento da estrutura"
           />
-          <input className="input" placeholder="Cliente" value={filters.cliente} onChange={(event) => setFilters((prev) => ({ ...prev, cliente: event.target.value }))} />
+          <input
+            className="input"
+            placeholder="Codigo do cliente"
+            value={clientCodeFilter}
+            onChange={(event) => setClientCodeFilter(event.target.value)}
+          />
           <SelectMenu
             value={filters.status}
             options={[
@@ -977,10 +1346,7 @@ const Vencimento = () => {
               <button
                 key={chip.key}
                 className="chip"
-                onClick={() => setFilters((prev) => ({
-                  ...prev,
-                  [chip.key]: Array.isArray(prev[chip.key]) ? [] : '',
-                }))}
+                onClick={() => chip.onClear?.()}
                 type="button"
               >
                 {chip.label}
@@ -990,7 +1356,10 @@ const Vencimento = () => {
             <button
               className="btn btn-secondary"
               type="button"
-              onClick={() => setFilters({ search: '', broker: '', assessor: '', cliente: '', status: '', estrutura: '', vencimentos: [] })}
+              onClick={() => {
+                setFilters({ search: '', broker: '', assessor: '', status: '', estrutura: '', vencimentos: [] })
+                setClientCodeFilter('')
+              }}
             >
               Limpar tudo
             </button>

diff --git "a/pwr_baseline_1\\pwr\\src\\components\\OverrideModal.jsx" "b/pwr\\src\\components\\OverrideModal.jsx"
index 9f02c1c..146f17e 100644
--- "a/pwr_baseline_1\\pwr\\src\\components\\OverrideModal.jsx"
+++ "b/pwr\\src\\components\\OverrideModal.jsx"
@@ -30,12 +30,13 @@ const OverrideModal = ({ open, onClose, value, onChange, onApply, onReset, qtyBa
           Cupom manual
           <input
             className="input"
-            type="text"
-            placeholder="Ex: 1.2%"
-            value={value.cupomManual ?? ''}
-            onChange={(event) => onChange({ ...value, cupomManual: event.target.value })}
+            type="number"
+            step="0.01"
+            placeholder="Ex: 1250"
+            value={value.manualCouponBRL ?? ''}
+            onChange={(event) => onChange({ ...value, manualCouponBRL: event.target.value })}
           />
-          <small className="muted">Deixa vazio para usar o cupom automatico.</small>
+          <small className="muted">Valor absoluto em R$. Deixa vazio para usar o cupom automatico.</small>
         </label>
       </div>
       <div className="override-grid">

diff --git "a/pwr_baseline_1\\pwr\\src\\components\\ReportModal.jsx" "b/pwr\\src\\components\\ReportModal.jsx"
index 641557a..9f5a43f 100644
--- "a/pwr_baseline_1\\pwr\\src\\components\\ReportModal.jsx"
+++ "b/pwr\\src\\components\\ReportModal.jsx"
@@ -17,13 +17,13 @@ const getBarrierBadge = (status) => {
 const ReportModal = ({ open, onClose, row, onExport, onCopy, onRefresh }) => {
   if (!row) return null
 
-  const clienteLabel = row.cliente || row.codigoCliente || '—'
+  const clienteLabel = row.nomeCliente || row.cliente || row.codigoCliente || '—'
   const spotLabel = row.spotBase ?? row.spotInicial
   const spotValue = spotLabel == null || Number.isNaN(Number(spotLabel)) ? '—' : formatNumber(spotLabel)
 
   const badge = getBarrierBadge(row.barrierStatus)
   const overrideManual = row.override?.high !== 'auto' || row.override?.low !== 'auto'
-  const cupomManual = row.cupomManual != null && String(row.cupomManual).trim() !== ''
+  const cupomManual = row.manualCouponBRL != null
   const warnings = []
 
   if (row.market?.source !== 'yahoo') {
@@ -115,15 +115,15 @@ const ReportModal = ({ open, onClose, row, onExport, onCopy, onRefresh }) => {
             </div>
             <div>
               <span>Ganho na Call</span>
-              <strong>{formatCurrency(row.result.ganhoCall)}</strong>
+              <strong>{row.result.optionsSuppressed ? 'N/A' : formatCurrency(row.result.ganhoCall)}</strong>
             </div>
             <div>
               <span>Ganho na Put</span>
-              <strong>{formatCurrency(row.result.ganhoPut)}</strong>
+              <strong>{row.result.optionsSuppressed ? 'N/A' : formatCurrency(row.result.ganhoPut)}</strong>
             </div>
             <div>
               <span>Ganhos nas opcoes</span>
-              <strong>{formatCurrency(row.result.ganhosOpcoes)}</strong>
+              <strong>{row.result.optionsSuppressed ? 'N/A' : formatCurrency(row.result.ganhosOpcoes)}</strong>
             </div>
             <div>
               <span>Dividendos</span>

diff --git "a/pwr_baseline_1\\pwr\\src\\services\\overrides.js" "b/pwr\\src\\services\\overrides.js"
index b7cbd92..08da383 100644
--- "a/pwr_baseline_1\\pwr\\src\\services\\overrides.js"
+++ "b/pwr\\src\\services\\overrides.js"
@@ -1,26 +1,104 @@
-﻿const STORAGE_KEY = 'pwr.vencimento.overrides'
+﻿const STORAGE_PREFIX = 'pwr.vencimento.overrides.'
+const LEGACY_KEY = 'pwr.vencimento.overrides'
 
-export const loadOverrides = () => {
+const buildKey = (userKey) => `${STORAGE_PREFIX}${userKey}`
+
+const parseNumber = (value) => {
+  if (value == null || value === '') return null
+  if (typeof value === 'number') return Number.isFinite(value) ? value : null
+  const raw = String(value).trim()
+  if (!raw) return null
+  let cleaned = raw.replace(/[^\d,.-]/g, '')
+  const hasComma = cleaned.includes(',')
+  const hasDot = cleaned.includes('.')
+  if (hasComma && hasDot) {
+    if (cleaned.lastIndexOf(',') > cleaned.lastIndexOf('.')) {
+      cleaned = cleaned.replace(/\./g, '').replace(/,/g, '.')
+    } else {
+      cleaned = cleaned.replace(/,/g, '')
+    }
+  } else if (hasComma) {
+    cleaned = cleaned.replace(/,/g, '.')
+  }
+  const parsed = Number(cleaned)
+  return Number.isFinite(parsed) ? parsed : null
+}
+
+const normalizeOverride = (override) => {
+  const base = {
+    high: 'auto',
+    low: 'auto',
+    manualCouponBRL: null,
+    manualCouponPct: null,
+    qtyBonus: 0,
+    bonusDate: '',
+    bonusNote: '',
+  }
+  const merged = { ...base, ...(override || {}) }
+  const manualCouponBRL = parseNumber(merged.manualCouponBRL ?? merged.manualCouponBrl)
+  const legacyRaw = merged.manualCouponPct ?? merged.cupomManual ?? merged.cupomManualPct
+  const legacy = legacyRaw != null && String(legacyRaw).trim() !== '' ? String(legacyRaw).trim() : null
+
+  return {
+    high: merged.high || 'auto',
+    low: merged.low || 'auto',
+    manualCouponBRL: manualCouponBRL != null ? manualCouponBRL : null,
+    manualCouponPct: legacy,
+    qtyBonus: Math.max(0, parseNumber(merged.qtyBonus) || 0),
+    bonusDate: merged.bonusDate || '',
+    bonusNote: merged.bonusNote || '',
+  }
+}
+
+const normalizeOverridesMap = (overrides) => {
+  if (!overrides || typeof overrides !== 'object') return {}
+  return Object.keys(overrides).reduce((acc, key) => {
+    acc[key] = normalizeOverride(overrides[key])
+    return acc
+  }, {})
+}
+
+export const loadOverrides = (userKey) => {
+  if (!userKey) return {}
+  let raw = null
   try {
-    const raw = localStorage.getItem(STORAGE_KEY)
+    raw = localStorage.getItem(buildKey(userKey))
+  } catch {
+    raw = null
+  }
+  if (!raw) {
+    try {
+      raw = localStorage.getItem(LEGACY_KEY)
+    } catch {
+      raw = null
+    }
     if (!raw) return {}
-    return JSON.parse(raw)
+    try {
+      const legacy = normalizeOverridesMap(JSON.parse(raw))
+      localStorage.setItem(buildKey(userKey), JSON.stringify(legacy))
+      localStorage.removeItem(LEGACY_KEY)
+      return legacy
+    } catch {
+      return {}
+    }
+  }
+  try {
+    return normalizeOverridesMap(JSON.parse(raw))
   } catch {
     return {}
   }
 }
 
-export const saveOverrides = (overrides) => {
-  localStorage.setItem(STORAGE_KEY, JSON.stringify(overrides))
+export const saveOverrides = (userKey, overrides) => {
+  if (!userKey) return
+  const normalized = normalizeOverridesMap(overrides)
+  localStorage.setItem(buildKey(userKey), JSON.stringify(normalized))
 }
 
 export const updateOverride = (overrides, id, next) => {
   return {
     ...overrides,
-    [id]: {
-      ...(overrides[id] || { high: 'auto', low: 'auto', cupomManual: '', qtyBonus: 0, bonusDate: '', bonusNote: '' }),
-      ...next,
-    },
+    [id]: normalizeOverride({ ...(overrides[id] || {}), ...next }),
   }
 }
 

diff --git "a/pwr_baseline_1\\pwr\\src\\services\\settlement.js" "b/pwr\\src\\services\\settlement.js"
index 42a4208..b716472 100644
--- "a/pwr_baseline_1\\pwr\\src\\services\\settlement.js"
+++ "b/pwr\\src\\services\\settlement.js"
@@ -7,6 +7,27 @@
   return parsed / 100
 }
 
+const toNumber = (value) => {
+  if (value == null || value === '') return null
+  if (typeof value === 'number') return Number.isFinite(value) ? value : null
+  const raw = String(value).trim()
+  if (!raw) return null
+  let cleaned = raw.replace(/[^\d,.-]/g, '')
+  const hasComma = cleaned.includes(',')
+  const hasDot = cleaned.includes('.')
+  if (hasComma && hasDot) {
+    if (cleaned.lastIndexOf(',') > cleaned.lastIndexOf('.')) {
+      cleaned = cleaned.replace(/\./g, '').replace(/,/g, '.')
+    } else {
+      cleaned = cleaned.replace(/,/g, '')
+    }
+  } else if (hasComma) {
+    cleaned = cleaned.replace(/,/g, '.')
+  }
+  const parsed = Number(cleaned)
+  return Number.isFinite(parsed) ? parsed : null
+}
+
 const resolveBarrierDirection = (type, barrierValue, spotInicial) => {
   const upper = (type || '').toUpperCase()
   if (upper.includes('UP') || upper.includes('UO') || upper.includes('UI')) return 'high'
@@ -109,7 +130,10 @@ export const computeResult = (operation, market, barrierStatus, override = {}) =
   const qtyBonusRaw = operation.qtyBonus ?? 0
   const qtyBase = Math.max(0, Number(qtyBaseRaw || 0))
   const qtyBonus = Math.max(0, Number(qtyBonusRaw || 0))
-  const qtyAtual = qtyBase + qtyBonus
+  const qtyAtualOverride = toNumber(operation.qtyAtual ?? operation.quantidadeAtual)
+  const hasQtyAtualOverride = qtyAtualOverride != null && qtyAtualOverride > 0
+  const qtyAtual = hasQtyAtualOverride ? qtyAtualOverride : qtyBase + qtyBonus
+  const qtyBonusResolved = hasQtyAtualOverride ? Math.max(0, qtyAtual - qtyBase) : qtyBonus
   const custoUnitario = Number(operation.custoUnitario || 0)
   const custoTotal = qtyBase * custoUnitario
   const pagouManual = operation.pagou != null && operation.pagou !== '' ? Number(operation.pagou) : null
@@ -127,6 +151,7 @@ export const computeResult = (operation, market, barrierStatus, override = {}) =
   const spotFinal = market?.close ?? operation.spotInicial ?? 0
   const vendaAtivoBruta = qtyAtual ? spotFinal * qtyAtual : 0
 
+  const isRecorrente = isCupomRecorrente(operation.estrutura)
   let ganhoCall = 0
   let ganhoPut = 0
 
@@ -152,10 +177,17 @@ export const computeResult = (operation, market, barrierStatus, override = {}) =
   }, 0)
 
   const dividends = (market?.dividendsTotal || 0) * (qtyAtual || 0)
-  const cupomBase = override?.cupomManual != null && String(override.cupomManual).trim() !== ''
-    ? override.cupomManual
-    : operation.cupom
-  const cupomTotal = custoTotal ? parsePercent(cupomBase) * custoTotal : 0
+  const manualCouponBRL = toNumber(override?.manualCouponBRL ?? override?.manualCouponBrl)
+  const legacyCoupon = override?.manualCouponPct ?? override?.cupomManual ?? override?.cupomManualPct
+  const legacyRaw = legacyCoupon != null && String(legacyCoupon).trim() !== '' ? String(legacyCoupon).trim() : null
+  const legacyConvertible = legacyRaw && legacyRaw.includes('%') && custoTotal
+  const legacyNeedsInput = Boolean(legacyRaw && !legacyConvertible)
+  const legacyConverted = Boolean(legacyConvertible)
+  const cupomTotal = manualCouponBRL != null
+    ? manualCouponBRL
+    : legacyConvertible
+      ? parsePercent(legacyRaw) * custoTotal
+      : (custoTotal ? parsePercent(operation.cupom) * custoTotal : 0)
 
   const rebateTotal = (operation.pernas || []).reduce((sum, leg) => {
     if (!leg?.rebate) return sum
@@ -165,7 +197,11 @@ export const computeResult = (operation, market, barrierStatus, override = {}) =
     return sum + Number(leg.rebate || 0) * qty
   }, 0)
 
-  const ganhosOpcoes = ganhoCall + ganhoPut
+  if (isRecorrente) {
+    ganhoCall = 0
+    ganhoPut = 0
+  }
+  const ganhosOpcoes = isRecorrente ? 0 : (ganhoCall + ganhoPut)
 
   const debito = (operation.pernas || []).reduce((sum, leg) => {
     if (!isLegActive(leg, barrierStatus)) return sum
@@ -200,19 +236,23 @@ export const computeResult = (operation, market, barrierStatus, override = {}) =
     vendaAtivoBruta,
     vendaAtivoAjustada,
     qtyBase,
-    qtyBonus,
+    qtyBonus: qtyBonusResolved,
     qtyAtual,
     valorSaida,
     custoTotal,
     pagou,
     valorEntrada: pagou,
     debito: Number.isFinite(debito) ? debito : 0,
-    payoff,
+    payoff: isRecorrente ? 0 : payoff,
     ganhoCall,
     ganhoPut,
     ganhosOpcoes,
+    optionsSuppressed: isRecorrente,
     dividends,
     cupomTotal,
+    cupomSource: manualCouponBRL != null ? 'manual-brl' : legacyConverted ? 'legacy-percent' : legacyNeedsInput ? 'legacy-needs-input' : 'auto',
+    cupomLegacyNeedsInput: legacyNeedsInput,
+    cupomLegacyConverted: legacyConverted,
     rebateTotal,
     financeiroFinal,
     ganho,

diff --git "a/pwr_baseline_1\\pwr\\src\\services\\excel.js" "b/pwr\\src\\services\\excel.js"
index f67d216..cbfe7e5 100644
--- "a/pwr_baseline_1\\pwr\\src\\services\\excel.js"
+++ "b/pwr\\src\\services\\excel.js"
@@ -153,6 +153,7 @@ const parsePosicaoConsolidada = (normalizedRow, fallbackRow, XLSX) => {
   }
 
   const spotInicial = toNumber(getValue(normalizedRow, ['valorativo']))
+  const quantidadeAtual = toNumber(getValue(normalizedRow, ['quantidadeatual', 'qtdatual', 'qtd_atual', 'posicaoatual', 'quantidadefinal', 'qtdeatual']))
   const custoUnitarioRaw = toNumber(getValue(normalizedRow, ['custounitariocliente']))
   const custoUnitario = custoUnitarioRaw > 0 ? custoUnitarioRaw : spotInicial
 
@@ -187,6 +188,7 @@ const parsePosicaoConsolidada = (normalizedRow, fallbackRow, XLSX) => {
     spotInicial: spotInicial ?? null,
     custoUnitario: custoUnitario ?? null,
     quantidade: quantidadeStock ?? 0,
+    quantidadeAtual: quantidadeAtual ?? null,
     cupom: getValue(normalizedRow, ['cupom', 'taxacupom']),
     pagou: toNumber(getValue(normalizedRow, ['pagou'])),
     pernas: legs,
@@ -281,6 +283,7 @@ const parseBuffer = (buffer, XLSX) => {
     const dataVencimento = normalizeDate(getValue(normalizedRow, ['datavencimento', 'datadevencimento', 'datafim', 'vencimento']), XLSX)
 
     const quantidade = toNumber(getValue(normalizedRow, ['quantidade', 'qtd', 'lote', 'quantidadeacoes', 'quantidadeacao', 'qtdacoes', 'qtdacao', 'estoque', 'posicao']))
+    const quantidadeAtual = toNumber(getValue(normalizedRow, ['quantidadeatual', 'qtdatual', 'qtd_atual', 'posicaoatual', 'quantidadefinal', 'qtdeatual']))
     const pernas = parseLegs(normalizedRow)
     const columnLegs = parseColumnLegs(normalizedRow, quantidade)
     const codigoCliente = resolveCodigoCliente(normalizedRow, fallbackRow?.[0])
@@ -314,6 +317,7 @@ const parseBuffer = (buffer, XLSX) => {
       spotInicial: toNumber(getValue(normalizedRow, ['spotinicial', 'spotentrada', 'spot', 'valordecompra', 'valorentrada'])),
       custoUnitario: toNumber(getValue(normalizedRow, ['custounitario', 'custounit', 'custo'])),
       quantidade: quantidade ?? 0,
+      quantidadeAtual: quantidadeAtual ?? null,
       cupom: getValue(normalizedRow, ['cupom', 'taxacupom']),
       pagou: toNumber(getValue(normalizedRow, ['pagou'])),
       pernas: pernas.length ? pernas : columnLegs,

diff --git "a/pwr_baseline_1\\pwr\\src\\pages\\RevenueStructured.jsx" "b/pwr\\src\\pages\\RevenueStructured.jsx"
index 9ed86f1..282d610 100644
--- "a/pwr_baseline_1\\pwr\\src\\pages\\RevenueStructured.jsx"
+++ "b/pwr\\src\\pages\\RevenueStructured.jsx"
@@ -7,31 +7,37 @@ import Icon from '../components/Icons'
 import { receitaEntries, receitaResumo } from '../data/revenue'
 import { formatCurrency, formatDate } from '../utils/format'
 import { useToast } from '../hooks/useToast'
+import { useGlobalFilters } from '../contexts/GlobalFilterContext'
+import { enrichRow } from '../services/tags'
 
 const RevenueStructured = () => {
   const { notify } = useToast()
+  const { selectedBroker, tagsIndex } = useGlobalFilters()
   const [filters, setFilters] = useState({ search: '', cliente: '', assessor: '', ativo: '', estrutura: '' })
   const [showWarnings, setShowWarnings] = useState(true)
 
   const rows = useMemo(() => {
     return receitaEntries
       .filter((entry) => entry.origem === 'Estruturadas')
+      .map((entry) => enrichRow(entry, tagsIndex))
       .filter((entry) => {
         const query = filters.search.toLowerCase()
-        if (query && !`${entry.cliente} ${entry.assessor} ${entry.ativo}`.toLowerCase().includes(query)) return false
-        if (filters.cliente && entry.cliente !== filters.cliente) return false
+        if (query && !`${entry.cliente} ${entry.nomeCliente || ''} ${entry.assessor} ${entry.ativo}`.toLowerCase().includes(query)) return false
+        if (selectedBroker && entry.broker !== selectedBroker) return false
+        if (filters.cliente && (entry.nomeCliente || entry.cliente) !== filters.cliente) return false
         if (filters.assessor && entry.assessor !== filters.assessor) return false
         if (filters.ativo && entry.ativo !== filters.ativo) return false
         if (filters.estrutura && entry.estrutura !== filters.estrutura) return false
         return true
       })
-  }, [filters])
+  }, [filters, selectedBroker, tagsIndex])
 
   const columns = useMemo(
     () => [
       { key: 'data', label: 'Data', render: (row) => formatDate(row.data) },
-      { key: 'cliente', label: 'Cliente' },
+      { key: 'cliente', label: 'Cliente', render: (row) => row.nomeCliente || row.cliente },
       { key: 'assessor', label: 'Assessor' },
+      { key: 'broker', label: 'Broker', render: (row) => row.broker || '—' },
       { key: 'ativo', label: 'Ativo' },
       { key: 'estrutura', label: 'Estrutura' },
       {

diff --git "a/pwr_baseline_1\\pwr\\src\\pages\\RevenueBovespa.jsx" "b/pwr\\src\\pages\\RevenueBovespa.jsx"
index dc72b75..76427f3 100644
--- "a/pwr_baseline_1\\pwr\\src\\pages\\RevenueBovespa.jsx"
+++ "b/pwr\\src\\pages\\RevenueBovespa.jsx"
@@ -6,28 +6,34 @@ import Badge from '../components/Badge'
 import Icon from '../components/Icons'
 import { receitaEntries, receitaResumo } from '../data/revenue'
 import { formatCurrency, formatDate } from '../utils/format'
+import { useGlobalFilters } from '../contexts/GlobalFilterContext'
+import { enrichRow } from '../services/tags'
 
 const RevenueBovespa = () => {
+  const { selectedBroker, tagsIndex } = useGlobalFilters()
   const [filters, setFilters] = useState({ search: '', ativo: '', cliente: '' })
 
   const rows = useMemo(() => {
     return receitaEntries
       .filter((entry) => entry.origem === 'Bovespa')
+      .map((entry) => enrichRow(entry, tagsIndex))
       .filter((entry) => {
         const query = filters.search.toLowerCase()
-        if (query && !`${entry.cliente} ${entry.ativo}`.toLowerCase().includes(query)) return false
+        if (query && !`${entry.cliente} ${entry.nomeCliente || ''} ${entry.ativo}`.toLowerCase().includes(query)) return false
+        if (selectedBroker && entry.broker !== selectedBroker) return false
         if (filters.ativo && entry.ativo !== filters.ativo) return false
-        if (filters.cliente && entry.cliente !== filters.cliente) return false
+        if (filters.cliente && (entry.nomeCliente || entry.cliente) !== filters.cliente) return false
         return true
       })
-  }, [filters])
+  }, [filters, selectedBroker, tagsIndex])
 
   const columns = useMemo(
     () => [
       { key: 'data', label: 'Data', render: (row) => formatDate(row.data) },
-      { key: 'cliente', label: 'Cliente' },
+      { key: 'cliente', label: 'Cliente', render: (row) => row.nomeCliente || row.cliente },
       { key: 'ativo', label: 'Ativo' },
       { key: 'estrutura', label: 'Estrutura' },
+      { key: 'broker', label: 'Broker', render: (row) => row.broker || '—' },
       {
         key: 'status',
         label: 'Status',

diff --git "a/pwr_baseline_1\\pwr\\src\\pages\\RevenueBmf.jsx" "b/pwr\\src\\pages\\RevenueBmf.jsx"
index 4068740..8e72b06 100644
--- "a/pwr_baseline_1\\pwr\\src\\pages\\RevenueBmf.jsx"
+++ "b/pwr\\src\\pages\\RevenueBmf.jsx"
@@ -6,26 +6,32 @@ import Badge from '../components/Badge'
 import Icon from '../components/Icons'
 import { receitaEntries, receitaResumo } from '../data/revenue'
 import { formatCurrency, formatDate } from '../utils/format'
+import { useGlobalFilters } from '../contexts/GlobalFilterContext'
+import { enrichRow } from '../services/tags'
 
 const RevenueBmf = () => {
+  const { selectedBroker, tagsIndex } = useGlobalFilters()
   const [filters, setFilters] = useState({ search: '', ativo: '' })
 
   const rows = useMemo(() => {
     return receitaEntries
       .filter((entry) => entry.origem === 'BMF')
+      .map((entry) => enrichRow(entry, tagsIndex))
       .filter((entry) => {
         const query = filters.search.toLowerCase()
-        if (query && !`${entry.cliente} ${entry.ativo}`.toLowerCase().includes(query)) return false
+        if (query && !`${entry.cliente} ${entry.nomeCliente || ''} ${entry.ativo}`.toLowerCase().includes(query)) return false
+        if (selectedBroker && entry.broker !== selectedBroker) return false
         if (filters.ativo && entry.ativo !== filters.ativo) return false
         return true
       })
-  }, [filters])
+  }, [filters, selectedBroker, tagsIndex])
 
   const columns = useMemo(
     () => [
       { key: 'data', label: 'Data', render: (row) => formatDate(row.data) },
-      { key: 'cliente', label: 'Cliente' },
+      { key: 'cliente', label: 'Cliente', render: (row) => row.nomeCliente || row.cliente },
       { key: 'assessor', label: 'Assessor' },
+      { key: 'broker', label: 'Broker', render: (row) => row.broker || '—' },
       { key: 'ativo', label: 'Contrato' },
       {
         key: 'status',

diff --git "a/pwr_baseline_1\\pwr\\src\\pages\\RevenueManual.jsx" "b/pwr\\src\\pages\\RevenueManual.jsx"
index 53dd33f..48efe8e 100644
--- "a/pwr_baseline_1\\pwr\\src\\pages\\RevenueManual.jsx"
+++ "b/pwr\\src\\pages\\RevenueManual.jsx"
@@ -4,6 +4,8 @@ import DataTable from '../components/DataTable'
 import Badge from '../components/Badge'
 import { formatCurrency, formatDate } from '../utils/format'
 import { useToast } from '../hooks/useToast'
+import { useGlobalFilters } from '../contexts/GlobalFilterContext'
+import { enrichRow } from '../services/tags'
 
 const initialEntries = [
   {
@@ -19,6 +21,7 @@ const initialEntries = [
 
 const RevenueManual = () => {
   const { notify } = useToast()
+  const { selectedBroker, tagsIndex } = useGlobalFilters()
   const [entries, setEntries] = useState(initialEntries)
   const [form, setForm] = useState({
     data: '2026-01-26',
@@ -55,8 +58,9 @@ const RevenueManual = () => {
   const columns = useMemo(
     () => [
       { key: 'data', label: 'Data', render: (row) => formatDate(row.data) },
-      { key: 'cliente', label: 'Cliente' },
+      { key: 'cliente', label: 'Cliente', render: (row) => row.nomeCliente || row.cliente },
       { key: 'assessor', label: 'Assessor' },
+      { key: 'broker', label: 'Broker', render: (row) => row.broker || '—' },
       { key: 'ativo', label: 'Ativo' },
       { key: 'valor', label: 'Valor', render: (row) => formatCurrency(row.valor) },
       { key: 'status', label: 'Status', render: () => <Badge tone="green">OK</Badge> },
@@ -64,6 +68,15 @@ const RevenueManual = () => {
     [],
   )
 
+  const rows = useMemo(() => {
+    return entries
+      .map((entry) => enrichRow(entry, tagsIndex))
+      .filter((entry) => {
+        if (selectedBroker && entry.broker !== selectedBroker) return false
+        return true
+      })
+  }, [entries, selectedBroker, tagsIndex])
+
   return (
     <div className="page">
       <PageHeader
@@ -118,7 +131,7 @@ const RevenueManual = () => {
             <p className="muted">Ultimos lancamentos manuais.</p>
           </div>
         </div>
-        <DataTable rows={entries} columns={columns} emptyMessage="Sem lancamentos manuais." />
+        <DataTable rows={rows} columns={columns} emptyMessage="Sem lancamentos manuais." />
       </section>
     </div>
   )

diff --git "a/pwr_baseline_1\\pwr\\src\\data\\revenue.js" "b/pwr\\src\\data\\revenue.js"
index dcd1416..4c1e448 100644
--- "a/pwr_baseline_1\\pwr\\src\\data\\revenue.js"
+++ "b/pwr\\src\\data\\revenue.js"
@@ -63,18 +63,3 @@ export const receitaResumo = {
   duplicados: 6,
   avisos: 4,
 }
-
-export const syncSteps = [
-  'Selecionar fonte',
-  'Validar arquivos',
-  'Processar linhas',
-  'Consolidar base',
-  'Concluir',
-]
-
-export const syncResultsMock = {
-  importados: 142,
-  duplicados: 6,
-  rejeitados: 2,
-  avisos: 4,
-}

diff --git a/.tmp_empty "b/pwr\\src\\contexts\\GlobalFilterContext.jsx"
index e69de29..772f10b 100644
--- a/.tmp_empty
+++ "b/pwr\\src\\contexts\\GlobalFilterContext.jsx"
@@ -0,0 +1,186 @@
+import {
+  createContext,
+  useCallback,
+  useContext,
+  useEffect,
+  useMemo,
+  useRef,
+  useState,
+} from 'react'
+import { getCurrentUserKey } from '../services/currentUser'
+import { buildTagIndex, loadTags } from '../services/tags'
+import { debugLog } from '../services/debug'
+
+const STORAGE_PREFIX = 'pwr.filters.'
+const BROADCAST_KEY = 'pwr.filters.broadcast'
+const BROADCAST_CHANNEL = 'pwr:filters'
+const STORAGE_VERSION = 1
+
+const buildKey = (userKey) => `${STORAGE_PREFIX}${userKey}`
+
+const normalizeValue = (value) => {
+  if (value == null) return ''
+  return String(value).trim()
+}
+
+const parseStored = (raw) => {
+  if (!raw) return null
+  try {
+    return JSON.parse(raw)
+  } catch {
+    return null
+  }
+}
+
+const GlobalFilterContext = createContext(null)
+
+export const GlobalFilterProvider = ({ children }) => {
+  const [userKey] = useState(() => getCurrentUserKey())
+  const [selectedBroker, setSelectedBroker] = useState('')
+  const [clientCodeFilter, setClientCodeFilter] = useState('')
+  const [tagsPayload, setTagsPayload] = useState(null)
+  const channelRef = useRef(null)
+  const senderRef = useRef(Math.random().toString(36).slice(2))
+  const loadedRef = useRef(false)
+  const applyingRemoteRef = useRef(false)
+
+  const tagsIndex = useMemo(() => buildTagIndex(tagsPayload), [tagsPayload])
+  const brokerOptions = useMemo(() => {
+    const base = tagsIndex?.brokers || []
+    return [{ value: '', label: 'Todos os brokers' }, ...base.map((item) => ({ value: item, label: item }))]
+  }, [tagsIndex])
+
+  const refreshTags = useCallback(async () => {
+    if (!userKey) return
+    const loaded = await loadTags(userKey)
+    setTagsPayload(loaded)
+  }, [userKey])
+
+  useEffect(() => {
+    refreshTags()
+  }, [refreshTags])
+
+  const applyRemote = useCallback((payload) => {
+    if (!payload) return
+    applyingRemoteRef.current = true
+    setSelectedBroker(normalizeValue(payload.broker))
+    setClientCodeFilter(normalizeValue(payload.clientCode))
+    setTimeout(() => {
+      applyingRemoteRef.current = false
+    }, 0)
+  }, [])
+
+  useEffect(() => {
+    if (!userKey) return
+    const stored = parseStored(localStorage.getItem(buildKey(userKey)))
+    if (stored) {
+      setSelectedBroker(normalizeValue(stored.broker))
+      setClientCodeFilter(normalizeValue(stored.clientCode))
+    }
+    loadedRef.current = true
+  }, [userKey])
+
+  useEffect(() => {
+    if (!userKey || !loadedRef.current || applyingRemoteRef.current) return
+    const payload = {
+      version: STORAGE_VERSION,
+      broker: normalizeValue(selectedBroker),
+      clientCode: normalizeValue(clientCodeFilter),
+      updatedAt: Date.now(),
+    }
+    try {
+      localStorage.setItem(buildKey(userKey), JSON.stringify(payload))
+    } catch {
+      // noop
+    }
+    const broadcastPayload = {
+      ...payload,
+      userKey,
+      sender: senderRef.current,
+    }
+    if (channelRef.current) {
+      channelRef.current.postMessage(broadcastPayload)
+    } else {
+      try {
+        localStorage.setItem(BROADCAST_KEY, JSON.stringify(broadcastPayload))
+      } catch {
+        // noop
+      }
+    }
+    debugLog('filters.change', { broker: payload.broker, clientCode: payload.clientCode })
+  }, [selectedBroker, clientCodeFilter, userKey])
+
+  useEffect(() => {
+    if (!userKey) return
+    if (typeof BroadcastChannel !== 'undefined') {
+      const channel = new BroadcastChannel(BROADCAST_CHANNEL)
+      channelRef.current = channel
+      channel.onmessage = (event) => {
+        const payload = event?.data
+        if (!payload || payload.sender === senderRef.current) return
+        if (payload.userKey !== userKey) return
+        applyRemote(payload)
+      }
+    }
+
+    const handleStorage = (event) => {
+      if (!event?.key) return
+      if (event.key === BROADCAST_KEY) {
+        const payload = parseStored(event.newValue)
+        if (!payload || payload.sender === senderRef.current) return
+        if (payload.userKey !== userKey) return
+        applyRemote(payload)
+        return
+      }
+      if (event.key === buildKey(userKey)) {
+        const payload = parseStored(event.newValue)
+        if (!payload) return
+        applyRemote(payload)
+        return
+      }
+    }
+
+    const handleTagsUpdate = (event) => {
+      if (event?.detail?.userKey && event.detail.userKey !== userKey) return
+      refreshTags()
+    }
+
+    window.addEventListener('storage', handleStorage)
+    window.addEventListener('pwr:tags-updated', handleTagsUpdate)
+
+    return () => {
+      window.removeEventListener('storage', handleStorage)
+      window.removeEventListener('pwr:tags-updated', handleTagsUpdate)
+      if (channelRef.current) {
+        channelRef.current.close()
+        channelRef.current = null
+      }
+    }
+  }, [applyRemote, refreshTags, userKey])
+
+  const value = useMemo(
+    () => ({
+      userKey,
+      selectedBroker,
+      setSelectedBroker,
+      clientCodeFilter,
+      setClientCodeFilter,
+      brokerOptions,
+      tagsIndex,
+      refreshTags,
+    }),
+    [userKey, selectedBroker, clientCodeFilter, brokerOptions, tagsIndex, refreshTags],
+  )
+
+  return (
+    <GlobalFilterContext.Provider value={value}>
+      {children}
+    </GlobalFilterContext.Provider>
+  )
+}
+
+export const useGlobalFilters = () => {
+  const ctx = useContext(GlobalFilterContext)
+  if (!ctx) throw new Error('useGlobalFilters must be used within GlobalFilterProvider')
+  return ctx
+}

diff --git a/.tmp_empty "b/pwr\\src\\services\\debug.js"
index e69de29..db81d2c 100644
--- a/.tmp_empty
+++ "b/pwr\\src\\services\\debug.js"
@@ -0,0 +1,22 @@
+const isBrowser = typeof window !== 'undefined'
+
+const isDebugEnabled = () => {
+  if (!isBrowser) return false
+  if (!import.meta?.env?.DEV) return false
+  try {
+    return window.localStorage.getItem('pwr.debug') === '1'
+  } catch {
+    return false
+  }
+}
+
+export const debugLog = (event, payload = null) => {
+  if (!isDebugEnabled()) return
+  if (payload == null) {
+    console.info(`[pwr:${event}]`)
+    return
+  }
+  console.info(`[pwr:${event}]`, payload)
+}
+
+export const debugEnabled = () => isDebugEnabled()

diff --git a/.tmp_empty "b/pwr\\src\\services\\currentUser.js"
index e69de29..ab1f72a 100644
--- a/.tmp_empty
+++ "b/pwr\\src\\services\\currentUser.js"
@@ -0,0 +1,68 @@
+const DEFAULT_USER_KEY = 'guest'
+
+const normalizeValue = (value) => {
+  if (value == null) return ''
+  if (typeof value === 'string') return value.trim()
+  if (typeof value === 'number') return String(value)
+  return ''
+}
+
+const normalizeKey = (value) => {
+  const raw = normalizeValue(value)
+  if (!raw) return ''
+  const lower = raw.toLowerCase()
+  if (lower.includes('@')) return `email:${lower}`
+  return `id:${lower}`
+}
+
+const pickFromObject = (obj) => {
+  if (!obj || typeof obj !== 'object') return ''
+  return normalizeKey(
+    obj.userKey
+    || obj.userId
+    || obj.id
+    || obj.sub
+    || obj.email
+    || obj.username
+    || obj.name,
+  )
+}
+
+const safeParse = (raw) => {
+  if (!raw) return null
+  try {
+    return JSON.parse(raw)
+  } catch {
+    return null
+  }
+}
+
+export const getCurrentUserKey = () => {
+  if (typeof window === 'undefined') return DEFAULT_USER_KEY
+
+  const directKey = normalizeKey(window.__PWR_USER_KEY__)
+  if (directKey) return directKey
+
+  const fromWindow = pickFromObject(window.__PWR_USER__) || pickFromObject(window.currentUser)
+  if (fromWindow) return fromWindow
+
+  const storageKeys = [
+    'pwr.userKey',
+    'pwr.user',
+    'pwr.currentUser',
+    'currentUser',
+    'auth.user',
+    'user',
+    'session.user',
+  ]
+
+  for (const key of storageKeys) {
+    const raw = window.localStorage.getItem(key)
+    if (!raw) continue
+    const parsed = safeParse(raw)
+    const candidate = parsed ? pickFromObject(parsed) : normalizeKey(raw)
+    if (candidate) return candidate
+  }
+
+  return DEFAULT_USER_KEY
+}

diff --git a/.tmp_empty "b/pwr\\src\\services\\tags.js"
index e69de29..54fc1c5 100644
--- a/.tmp_empty
+++ "b/pwr\\src\\services\\tags.js"
@@ -0,0 +1,296 @@
+import { debugLog } from './debug'
+
+const TAGS_VERSION = 1
+const XLSX_URL = 'https://cdn.sheetjs.com/xlsx-0.20.3/package/xlsx.mjs'
+const TAGS_DB_NAME = 'pwr-tags'
+const TAGS_STORE = 'tags'
+const TAGS_DB_VERSION = 1
+const memoryCache = new Map()
+
+const normalizeKey = (value) => String(value || '')
+  .toLowerCase()
+  .normalize('NFD')
+  .replace(/[\u0300-\u036f]/g, '')
+  .replace(/[^a-z0-9]/g, '')
+
+const normalizeValue = (value) => {
+  if (value == null) return ''
+  if (typeof value === 'string') return value.trim()
+  if (typeof value === 'number') return String(value)
+  return String(value).trim()
+}
+
+const normalizeLabel = (value, fallback) => {
+  const raw = normalizeValue(value)
+  if (!raw || raw === '0') return fallback
+  return raw
+}
+
+const toArrayBuffer = async (input) => {
+  if (!input) return null
+  if (input instanceof ArrayBuffer) return input
+  if (ArrayBuffer.isView(input)) {
+    return input.buffer.slice(input.byteOffset, input.byteOffset + input.byteLength)
+  }
+  if (typeof input.arrayBuffer === 'function') {
+    return input.arrayBuffer()
+  }
+  return null
+}
+
+const getValue = (row, keys, fallback) => {
+  if (row) {
+    for (const key of keys) {
+      if (row[key] != null && row[key] !== '') return row[key]
+    }
+  }
+  if (fallback != null && fallback !== '') return fallback
+  return null
+}
+
+const CLIENTE_KEYS = ['cliente', 'codcliente', 'codigocliente', 'codigo', 'codigodocliente', 'conta', 'numerodaconta']
+const ASSESSOR_KEYS = ['assessor', 'consultor', 'assessorresponsavel']
+const BROKER_KEYS = ['broker', 'corretora', 'canaldeorigem', 'canal', 'origem']
+const NOME_CLIENTE_KEYS = ['nomecliente', 'nomedocliente', 'razaosocial', 'clientenome']
+
+const isHeaderRow = (cliente, assessor, broker, nomeCliente) => {
+  const header = [cliente, assessor, broker, nomeCliente]
+    .filter(Boolean)
+    .map((item) => normalizeKey(item))
+  return header.includes('cliente') && (header.includes('assessor') || header.includes('broker') || header.includes('nomecliente'))
+}
+
+const normalizeTagKey = (value) => {
+  const raw = normalizeValue(value)
+  if (!raw) return ''
+  return normalizeKey(raw)
+}
+
+const looksLikeCode = (value) => {
+  const raw = normalizeValue(value)
+  if (!raw) return false
+  return /^\d+$/.test(raw)
+}
+
+const openTagsDb = () => new Promise((resolve, reject) => {
+  if (typeof indexedDB === 'undefined') {
+    reject(new Error('indexeddb-unavailable'))
+    return
+  }
+  const request = indexedDB.open(TAGS_DB_NAME, TAGS_DB_VERSION)
+  request.onupgradeneeded = () => {
+    const db = request.result
+    if (!db.objectStoreNames.contains(TAGS_STORE)) {
+      db.createObjectStore(TAGS_STORE)
+    }
+  }
+  request.onsuccess = () => resolve(request.result)
+  request.onerror = () => reject(request.error)
+})
+
+const readPayload = async (userKey) => {
+  try {
+    const db = await openTagsDb()
+    return await new Promise((resolve) => {
+      const tx = db.transaction(TAGS_STORE, 'readonly')
+      const store = tx.objectStore(TAGS_STORE)
+      const request = store.get(userKey)
+      request.onsuccess = () => resolve(request.result || null)
+      request.onerror = () => resolve(null)
+      tx.oncomplete = () => db.close()
+      tx.onabort = () => {
+        db.close()
+        resolve(null)
+      }
+    })
+  } catch {
+    return null
+  }
+}
+
+const writePayload = async (userKey, payload) => {
+  try {
+    const db = await openTagsDb()
+    return await new Promise((resolve) => {
+      const tx = db.transaction(TAGS_STORE, 'readwrite')
+      const store = tx.objectStore(TAGS_STORE)
+      store.put(payload, userKey)
+      tx.oncomplete = () => {
+        db.close()
+        resolve(true)
+      }
+      tx.onabort = () => {
+        db.close()
+        resolve(false)
+      }
+    })
+  } catch {
+    return false
+  }
+}
+
+const deletePayload = async (userKey) => {
+  try {
+    const db = await openTagsDb()
+    return await new Promise((resolve) => {
+      const tx = db.transaction(TAGS_STORE, 'readwrite')
+      const store = tx.objectStore(TAGS_STORE)
+      store.delete(userKey)
+      tx.oncomplete = () => {
+        db.close()
+        resolve(true)
+      }
+      tx.onabort = () => {
+        db.close()
+        resolve(false)
+      }
+    })
+  } catch {
+    return false
+  }
+}
+
+export const parseTagsXlsx = async (input) => {
+  const buffer = await toArrayBuffer(input)
+  if (!buffer) throw new Error('buffer-invalid')
+  const XLSX = await import(/* @vite-ignore */ XLSX_URL)
+  const workbook = XLSX.read(buffer, { type: 'array', cellDates: true })
+  const sheetName = workbook.SheetNames?.find((name) => normalizeKey(name) === 'planilha1') || workbook.SheetNames?.[0]
+  if (!sheetName) throw new Error('sheet-missing')
+  const sheet = workbook.Sheets[sheetName]
+  const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' })
+  const rawRows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' })
+  const rowOffset = rawRows.length > rows.length ? 1 : 0
+
+  const parsedRows = []
+  const seen = new Set()
+  const stats = { importados: 0, duplicados: 0, rejeitados: 0, avisos: 0 }
+
+  rows.forEach((row, index) => {
+    const normalizedRow = Object.keys(row).reduce((acc, key) => {
+      acc[normalizeKey(key)] = row[key]
+      return acc
+    }, {})
+    const fallbackRow = rawRows[rowOffset + index] || []
+
+    const cliente = normalizeValue(getValue(normalizedRow, CLIENTE_KEYS, fallbackRow[0]))
+    const assessor = normalizeLabel(getValue(normalizedRow, ASSESSOR_KEYS, fallbackRow[1]), 'Sem assessor')
+    const broker = normalizeLabel(getValue(normalizedRow, BROKER_KEYS, fallbackRow[2]), 'Sem broker')
+    const nomeCliente = normalizeValue(getValue(normalizedRow, NOME_CLIENTE_KEYS, fallbackRow[3]))
+
+    if (isHeaderRow(cliente, assessor, broker, nomeCliente)) return
+    if (!cliente && !nomeCliente) {
+      stats.rejeitados += 1
+      return
+    }
+
+    const key = normalizeTagKey(cliente || nomeCliente)
+    if (!key) {
+      stats.rejeitados += 1
+      return
+    }
+    if (seen.has(key)) {
+      stats.duplicados += 1
+      return
+    }
+    seen.add(key)
+    if (assessor === 'Sem assessor' || broker === 'Sem broker') stats.avisos += 1
+
+    parsedRows.push({
+      id: key,
+      cliente: cliente || '',
+      assessor,
+      broker,
+      nomeCliente: nomeCliente || '',
+    })
+  })
+
+  stats.importados = parsedRows.length
+
+  debugLog('tags.import.parse', { total: parsedRows.length, duplicados: stats.duplicados, rejeitados: stats.rejeitados })
+
+  return {
+    version: TAGS_VERSION,
+    importedAt: Date.now(),
+    rows: parsedRows,
+    stats,
+    source: 'xlsx',
+    sheetName,
+  }
+}
+
+export const saveTags = async (userKey, payload) => {
+  if (!userKey || !payload) return null
+  const stored = {
+    version: payload.version || TAGS_VERSION,
+    importedAt: payload.importedAt || Date.now(),
+    rows: payload.rows || [],
+    stats: payload.stats || null,
+    source: payload.source || 'unknown',
+    sheetName: payload.sheetName || null,
+  }
+  const ok = await writePayload(userKey, stored)
+  if (!ok) return null
+  memoryCache.set(userKey, stored)
+  debugLog('tags.import.saved', { total: stored.rows.length })
+  return stored
+}
+
+export const loadTags = async (userKey) => {
+  if (!userKey) return null
+  if (memoryCache.has(userKey)) return memoryCache.get(userKey)
+  const payload = await readPayload(userKey)
+  if (payload) memoryCache.set(userKey, payload)
+  return payload
+}
+
+export const clearTags = async (userKey) => {
+  if (!userKey) return
+  memoryCache.delete(userKey)
+  await deletePayload(userKey)
+}
+
+export const buildTagIndex = (payload) => {
+  const rows = Array.isArray(payload?.rows) ? payload.rows : []
+  const byCliente = new Map()
+  const byNome = new Map()
+  const brokers = new Set()
+
+  rows.forEach((row) => {
+    if (row?.broker) brokers.add(row.broker)
+    const clienteKey = normalizeTagKey(row?.cliente)
+    if (clienteKey && !byCliente.has(clienteKey)) byCliente.set(clienteKey, row)
+    const nomeKey = normalizeTagKey(row?.nomeCliente)
+    if (nomeKey && !byNome.has(nomeKey)) byNome.set(nomeKey, row)
+  })
+
+  return {
+    rows,
+    byCliente,
+    byNome,
+    brokers: Array.from(brokers).sort((a, b) => a.localeCompare(b, 'pt-BR')),
+  }
+}
+
+export const enrichRow = (row, tagIndex) => {
+  if (!row || !tagIndex) return row
+  const rawCode = row.codigoCliente || row.clienteCodigo || row.codCliente || row.cliente
+  const codeKey = normalizeTagKey(rawCode)
+  const nameKey = normalizeTagKey(row.nomeCliente || row.cliente)
+  const tag = (codeKey && tagIndex.byCliente?.get(codeKey)) || (nameKey && tagIndex.byNome?.get(nameKey))
+  if (!tag) return row
+
+  const next = { ...row }
+  if (tag.assessor) next.assessor = tag.assessor
+  if (tag.broker) next.broker = tag.broker
+  if (tag.nomeCliente) next.nomeCliente = tag.nomeCliente
+  if (tag.cliente && !next.codigoCliente) next.codigoCliente = tag.cliente
+
+  if (!next.cliente || looksLikeCode(next.cliente)) {
+    next.cliente = tag.nomeCliente || tag.cliente || next.cliente
+  }
+
+  return next
+}
+
+export const normalizeTagLookup = (value) => normalizeTagKey(value)

diff --git a/.tmp_empty "b/pwr\\src\\services\\vencimentoLink.js"
index e69de29..be8bc38 100644
--- a/.tmp_empty
+++ "b/pwr\\src\\services\\vencimentoLink.js"
@@ -0,0 +1,164 @@
+const STORAGE_PREFIX = 'pwr.vencimento.link.'
+const HANDLE_DB_NAME = 'pwr-vencimento'
+const HANDLE_STORE = 'folder-handles'
+const HANDLE_VERSION = 1
+
+const buildKey = (userKey) => `${STORAGE_PREFIX}${userKey}`
+
+const safeParse = (raw) => {
+  if (!raw) return null
+  try {
+    return JSON.parse(raw)
+  } catch {
+    return null
+  }
+}
+
+const openHandleDb = () => new Promise((resolve, reject) => {
+  if (typeof indexedDB === 'undefined') {
+    reject(new Error('indexeddb-unavailable'))
+    return
+  }
+  const request = indexedDB.open(HANDLE_DB_NAME, HANDLE_VERSION)
+  request.onupgradeneeded = () => {
+    const db = request.result
+    if (!db.objectStoreNames.contains(HANDLE_STORE)) {
+      db.createObjectStore(HANDLE_STORE)
+    }
+  }
+  request.onsuccess = () => resolve(request.result)
+  request.onerror = () => reject(request.error)
+})
+
+const readHandle = async (userKey) => {
+  try {
+    const db = await openHandleDb()
+    return await new Promise((resolve) => {
+      const tx = db.transaction(HANDLE_STORE, 'readonly')
+      const store = tx.objectStore(HANDLE_STORE)
+      const request = store.get(userKey)
+      request.onsuccess = () => resolve(request.result || null)
+      request.onerror = () => resolve(null)
+      tx.oncomplete = () => db.close()
+      tx.onabort = () => {
+        db.close()
+        resolve(null)
+      }
+    })
+  } catch {
+    return null
+  }
+}
+
+const writeHandle = async (userKey, handle) => {
+  try {
+    const db = await openHandleDb()
+    return await new Promise((resolve) => {
+      const tx = db.transaction(HANDLE_STORE, 'readwrite')
+      const store = tx.objectStore(HANDLE_STORE)
+      store.put(handle, userKey)
+      tx.oncomplete = () => {
+        db.close()
+        resolve(true)
+      }
+      tx.onabort = () => {
+        db.close()
+        resolve(false)
+      }
+    })
+  } catch {
+    return false
+  }
+}
+
+const deleteHandle = async (userKey) => {
+  try {
+    const db = await openHandleDb()
+    return await new Promise((resolve) => {
+      const tx = db.transaction(HANDLE_STORE, 'readwrite')
+      const store = tx.objectStore(HANDLE_STORE)
+      store.delete(userKey)
+      tx.oncomplete = () => {
+        db.close()
+        resolve(true)
+      }
+      tx.onabort = () => {
+        db.close()
+        resolve(false)
+      }
+    })
+  } catch {
+    return false
+  }
+}
+
+export const isValidElectronPath = (value) => {
+  if (!value || typeof value !== 'string') return false
+  const trimmed = value.trim()
+  return trimmed.length > 2
+}
+
+export const ensurePermission = async (handle, { interactive = false } = {}) => {
+  if (!handle || typeof handle.queryPermission !== 'function') return 'unavailable'
+  try {
+    let state = await handle.queryPermission({ mode: 'read' })
+    if (state === 'granted') return state
+    if (interactive && typeof handle.requestPermission === 'function') {
+      state = await handle.requestPermission({ mode: 'read' })
+    }
+    return state
+  } catch {
+    return 'denied'
+  }
+}
+
+export const saveLink = async (userKey, link) => {
+  if (!userKey) return null
+  if (!link || typeof link !== 'object') return null
+  const payload = {
+    version: 1,
+    source: link.source || 'browser',
+    folderPath: link.folderPath || null,
+    folderName: link.folderName || null,
+    fileName: link.fileName || null,
+    savedAt: Date.now(),
+  }
+  try {
+    localStorage.setItem(buildKey(userKey), JSON.stringify(payload))
+  } catch {
+    return null
+  }
+  if (payload.source === 'browser' && link.handle) {
+    await writeHandle(userKey, link.handle)
+  } else {
+    await deleteHandle(userKey)
+  }
+  return payload
+}
+
+export const loadLink = async (userKey) => {
+  if (!userKey) return null
+  let raw = null
+  try {
+    raw = localStorage.getItem(buildKey(userKey))
+  } catch {
+    raw = null
+  }
+  if (!raw) return null
+  const parsed = safeParse(raw)
+  if (!parsed) return null
+  if (parsed.source === 'browser') {
+    parsed.handle = await readHandle(userKey)
+  }
+  return parsed
+}
+
+export const clearLink = async (userKey) => {
+  if (!userKey) return
+  try {
+    localStorage.removeItem(buildKey(userKey))
+  } catch {
+    // noop
+  }
+  await deleteHandle(userKey)
+}

diff --git a/.tmp_empty "b/pwr\\src\\services\\vencimentoCache.js"
index e69de29..a470a72 100644
--- a/.tmp_empty
+++ "b/pwr\\src\\services\\vencimentoCache.js"
@@ -0,0 +1,82 @@
+const STORAGE_PREFIX = 'pwr.vencimento.cache.'
+const MAX_CACHE_BYTES = 2_000_000
+const MAX_CACHE_ROWS = 500
+
+const buildKey = (userKey) => `${STORAGE_PREFIX}${userKey}`
+
+const safeParse = (raw) => {
+  if (!raw) return null
+  try {
+    return JSON.parse(raw)
+  } catch {
+    return null
+  }
+}
+
+const serializeWithLimit = (payload) => {
+  const raw = JSON.stringify(payload)
+  if (raw.length <= MAX_CACHE_BYTES) {
+    return { raw, payload }
+  }
+
+  const rows = Array.isArray(payload.rows) ? payload.rows : []
+  const trimmed = rows.slice(0, MAX_CACHE_ROWS)
+  const trimmedPayload = {
+    ...payload,
+    rows: trimmed,
+    truncated: true,
+    totalRows: rows.length,
+  }
+  const trimmedRaw = JSON.stringify(trimmedPayload)
+  if (trimmedRaw.length <= MAX_CACHE_BYTES) {
+    return { raw: trimmedRaw, payload: trimmedPayload }
+  }
+
+  const minimalPayload = {
+    ...payload,
+    rows: [],
+    truncated: true,
+    totalRows: rows.length,
+    cacheError: 'size-limit',
+  }
+  return { raw: JSON.stringify(minimalPayload), payload: minimalPayload }
+}
+
+export const saveLastImported = (userKey, payload) => {
+  if (!userKey || !payload) return null
+  const data = {
+    version: 1,
+    importedAt: payload.importedAt || Date.now(),
+    source: payload.source || 'unknown',
+    fileName: payload.fileName || null,
+    rows: payload.rows || [],
+  }
+  const { raw, payload: stored } = serializeWithLimit(data)
+  try {
+    localStorage.setItem(buildKey(userKey), raw)
+  } catch {
+    return null
+  }
+  return stored
+}
+
+export const loadLastImported = (userKey) => {
+  if (!userKey) return null
+  let raw = null
+  try {
+    raw = localStorage.getItem(buildKey(userKey))
+  } catch {
+    raw = null
+  }
+  if (!raw) return null
+  return safeParse(raw)
+}
+
+export const clearLastImported = (userKey) => {
+  if (!userKey) return
+  try {
+    localStorage.removeItem(buildKey(userKey))
+  } catch {
+    // noop
+  }
+}

